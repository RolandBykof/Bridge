<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BridgeCircle - Multiplayer Game</title>
    <link rel="stylesheet" href="css/main.css">
    <meta name="description" content="Bridge multiplayer game in progress">
</head>
<body>
    <div class="container" id="game-view">
        <h1>BridgeCircle - Table <span id="table-code-title"></span></h1>
        
        <!-- ARIA Live area for announcements -->
        <div id="status-announcer" aria-live="polite" class="sr-only"></div>
        
        <!-- Error message container -->
        <div id="error-area" class="error-message" style="display: none;"></div>
        
        <!-- Player management -->
        <section class="section">
            <h2>Players</h2>
            <div class="player-controls" id="players-area">
                <!-- Player information will be added here with JavaScript -->
            </div>
        </section>
        
        <!-- Status message -->
        <div class="status-bar" id="status-area" role="status">
            Welcome to BridgeCircle Multiplayer
        </div>
        
        <!-- Action buttons -->
        <div class="action-buttons">
            <button onclick="toggleHelp()" id="toggle-help-button" class="button button-secondary" aria-expanded="false">
                Show Help
            </button>
            
            <button onclick="startNewGame()" id="new-game-button" class="button" style="display: none;">
                Start New Game
            </button>
            
            <button onclick="leaveGame()" class="button button-secondary">
                Leave Game
            </button>
            
            <button onclick="fullscreen()" id="fullscreen-button" class="button button-secondary">
                Full Screen
            </button>
        </div>
        
        <!-- Help section (hidden initially) -->
        <section class="help-section" id="help-section" style="display: none;" role="dialog" aria-labelledby="help-title">
            <h2 id="help-title">Keyboard Shortcuts</h2>
            <ul class="help-list" id="help-list">
                <!-- Will be populated by JavaScript -->
            </ul>
            <button onclick="closeHelp()" id="close-help-button" class="button">
                Close Help
            </button>
        </section>
        
        <!-- Bidding area -->
        <section class="section" id="bidding-area" style="display: none;">
            <h2>Bidding Phase</h2>
            <div id="bidding-history" class="bidding-history">
                <h3>Bidding History</h3>
                <p>No bids yet.</p>
            </div>
            <div id="bidding-controls" class="bidding-controls">
                <h3>Your Bid</h3>
                <p>Waiting for bidding to start...</p>
            </div>
        </section>
        
        <!-- Game table -->
        <div class="game-table">
            <!-- North (top) -->
            <div class="hand north-hand" id="north-hand">
                <h3>North</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
            
            <!-- East (right) -->
            <div class="hand east-hand" id="east-hand">
                <h3>East</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- Center area -->
            <div class="center-area" id="center-area">
                <!-- Played cards and center information will be added here -->
                <p>Wait for game to start...</p>
            </div>
            
            <!-- West (left) -->
            <div class="hand west-hand" id="west-hand">
                <h3>West</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- South (bottom - player's hand) -->
            <div class="hand south-hand" id="south-hand">
                <h3>Your Hand</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
        </div>
        
        <!-- Current trick cards -->
        <section class="section" id="played-cards-area">
            <h2>Current Trick</h2>
            <div id="played-cards-container">
                <p class="text-gray-500">No cards played in current trick yet.</p>
            </div>
        </section>
        
        <!-- Chat Section -->
        <div class="section">
            <h2>Game Chat</h2>
            <div id="chat-messages" class="chat-messages" aria-live="polite"></div>
            <div class="chat-input-container">
                <label for="chat-input" class="sr-only">Type a message</label>
                <input type="text" id="chat-input" class="chat-input" 
                       placeholder="Type a message...">
                <button onclick="sendChatMessage()" class="button">Send</button>
            </div>
        </div>
    </div>
    
    <!-- JavaScript files -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/bridge.js"></script>
    <script>
        // MULTIPLAYER GAME VARIABLES (adapted from playsolo)
        let tableCode = null;
        let gameState = null;
        let biddingState = null;
        let myPosition = null; // Will be set when player joins
        let trickClearTimeout = null;

        // UI state for keyboard shortcuts
        const uiState = {
            showHelp: false,
            lastAnnouncement: '',
            bidLevel: null,
        };

        // DOM references (same as playsolo)
        const elements = {
            statusAnnouncer: document.getElementById('status-announcer'),
            helpSection: document.getElementById('help-section'),
            helpList: document.getElementById('help-list'),
            toggleHelpButton: document.getElementById('toggle-help-button'),
            closeHelpButton: document.getElementById('close-help-button'),
            newGameButton: document.getElementById('new-game-button'),
            biddingArea: document.getElementById('bidding-area'),
            biddingHistory: document.getElementById('bidding-history'),
            biddingControls: document.getElementById('bidding-controls'),
            northHand: document.getElementById('north-hand'),
            eastHand: document.getElementById('east-hand'),
            westHand: document.getElementById('west-hand'),
            southHand: document.getElementById('south-hand'),
            centerArea: document.getElementById('center-area'),
            playedCardsContainer: document.getElementById('played-cards-container')
        };

        // ANNOUNCEMENT SYSTEM (same as playsolo)
        const announcementQueue = {
            queue: [],
            processing: false,
            currentTimeout: null,

            add(message) {
                uiState.lastAnnouncement = message;
                this.queue.push({
                    message: message,
                    timestamp: Date.now(),
                    estimatedDuration: this.estimateDuration(message)
                });

                if (!this.processing) {
                    this.processNext();
                }
            },

            estimateDuration(message) {
                const baseRate = 150;
                const minDuration = 2000;
                const maxDuration = 2000;
                let estimated = message.length * baseRate;
                const punctuationCount = (message.match(/[.!?;,]/g) || []).length;
                estimated += punctuationCount * 400;
                return Math.max(minDuration, Math.min(maxDuration, estimated));
            },

            processNext() {
                if (this.queue.length === 0) {
                    this.processing = false;
                    return;
                }

                this.processing = true;
                const announcement = this.queue.shift();
                elements.statusAnnouncer.textContent = '';

                setTimeout(() => {
                    elements.statusAnnouncer.textContent = announcement.message;
                    this.currentTimeout = setTimeout(() => {
                        this.processNext();
                    }, announcement.estimatedDuration);
                }, 100);
            },

            clear() {
                this.queue = [];
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                elements.statusAnnouncer.textContent = '';
                this.processing = false;
            },

            repeatLast() {
                if (uiState.lastAnnouncement) {
                    this.clear();
                    this.add(uiState.lastAnnouncement);
                }
            }
        };

        function announceToScreenReader(message) {
            announcementQueue.add(message);
        }

        function showErrorWithAnnouncement(message) {
            showError(message);
            announceToScreenReader(message);
        }

        // CARD PLAY VALIDATION (same advanced logic as playsolo)
        function attemptToPlayCard(suit, card, fromPosition) {
            console.log('Attempting to play card:', { suit, card, fromPosition, gameState });
            
            if (!tableCode) {
                showErrorWithAnnouncement('No game in progress.');
                return;
            }
            
            if (!gameState) {
                showErrorWithAnnouncement('Game state not available.');
                return;
            }
            
            if (gameState.gamePhase !== 'play') {
                showErrorWithAnnouncement('Game is not in play phase.');
                return;
            }
            
            const actualPosition = fromPosition || myPosition;
            const currentPlayer = gameState.currentPlayer;
            
            // MULTIPLAYER LOGIC: Check if we can control this position
            let isValidTurn = false;
            
            if (currentPlayer === myPosition && actualPosition === myPosition) {
                isValidTurn = true;
                console.log('Valid: Playing from our own position');
            } else if (currentPlayer === gameState.dummy && actualPosition === gameState.dummy) {
                // Check if we can control dummy
                if (gameState.declarer === myPosition) {
                    isValidTurn = true;
                    console.log('Valid: Playing from dummy as declarer');
                } else {
                    console.log('Invalid: Cannot control dummy - not declarer');
                }
            } else {
                console.log('Invalid: Wrong turn or position');
            }
            
            if (!isValidTurn) {
                const currentPlayerName = getPositionName(currentPlayer);
                showErrorWithAnnouncement(`It's ${currentPlayerName}'s turn to play, not yours.`);
                return;
            }
            
            // Check if we have the card
            const hand = gameState.hands[actualPosition];
            if (!hand || !hand[suit] || !hand[suit].includes(card)) {
                showErrorWithAnnouncement(`You don't have the ${getSuitName(suit)} ${card}.`);
                return;
            }
            
            // Check suit following rules
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    showErrorWithAnnouncement(`You must follow suit and play a ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            console.log('All validations passed, playing card');
            sendCardToServer(suit, card, actualPosition);
        }
        
        function sendCardToServer(suit, card, position) {
            socket.emit('playCard', {
                tableCode: tableCode,
                position: position,
                suit: suit,
                card: card
            });
        }

        // KEYBOARD SHORTCUTS (adapted from playsolo for multiplayer)
        const keyboardShortcuts = [
            // Card viewing shortcuts (Own cards)
            { key: 'a', alt: true, description: 'Read your spades and focus on lowest', action: () => announceHandSuitWithFocus(myPosition, 'spades') },
            { key: 's', alt: true, description: 'Read your hearts and focus on lowest', action: () => announceHandSuitWithFocus(myPosition, 'hearts') },
            { key: 'd', alt: true, description: 'Read your diamonds and focus on lowest', action: () => announceHandSuitWithFocus(myPosition, 'diamonds') },
            { key: 'f', alt: true, description: 'Read your clubs and focus on lowest', action: () => announceHandSuitWithFocus(myPosition, 'clubs') },
            { key: 'g', alt: true, description: 'Read all your cards', action: () => announceEntireHand(myPosition) },

            // Card viewing shortcuts (Dummy's cards)
            { key: 'q', alt: true, description: 'Read dummy spades and focus on lowest', action: () => {
                if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                    announceHandSuitWithFocus(gameState.dummy, 'spades');
                } else {
                    announceToScreenReader('Cannot view dummy spades at this time.');
                }
            }},
            { key: 'w', alt: true, description: 'Read dummy hearts and focus on lowest', action: () => {
                if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                    announceHandSuitWithFocus(gameState.dummy, 'hearts');
                } else {
                    announceToScreenReader('Cannot view dummy hearts at this time.');
                }
            }},
            { key: 'e', alt: true, description: 'Read dummy diamonds and focus on lowest', action: () => {
                if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                    announceHandSuitWithFocus(gameState.dummy, 'diamonds');
                } else {
                    announceToScreenReader('Cannot view dummy diamonds at this time.');
                }
            }},
            { key: 'r', alt: true, description: 'Read dummy clubs and focus on lowest', action: () => {
                if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                    announceHandSuitWithFocus(gameState.dummy, 'clubs');
                } else {
                    announceToScreenReader('Cannot view dummy clubs at this time.');
                }
            }},
            { key: 't', alt: true, description: 'Read all dummy cards', action: () => {
                if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                    announceEntireHand(gameState.dummy);
                } else {
                    announceToScreenReader('Cannot view all dummy cards at this time.');
                }
            }},

            // Game state shortcuts
            { key: 'z', alt: true, description: 'Read current trick', action: () => announceCurrentTrick() },
            { key: 'x', alt: true, description: 'Read game state', action: () => announceGameState() },
            { key: 'c', alt: true, description: 'Announce current player', action: () => announceCurrentPlayer() },
            { key: 'v', alt: true, description: 'Read last played trick', action: () => announceLastTrick() },
            
            // Bidding shortcuts
            { key: 'p', alt: true, description: 'Bid Pass', action: () => makeBidShortcut('P') },
            { key: 'd', alt: true, description: 'Bid Double', action: () => makeBidShortcut('X') },
            { key: 'f', alt: true, description: 'Bid Redouble', action: () => makeBidShortcut('XX') },
            
            // Card playing shortcuts - high cards
            { key: '1', ctrl: true, description: 'Play highest spade', action: () => playHighestCard('spades') },
            { key: '2', ctrl: true, description: 'Play highest heart', action: () => playHighestCard('hearts') },
            { key: '3', ctrl: true, description: 'Play highest diamond', action: () => playHighestCard('diamonds') },
            { key: '4', ctrl: true, description: 'Play highest club', action: () => playHighestCard('clubs') },
            
            // Card playing shortcuts - low cards
            { key: '1', ctrl: true, shift: true, description: 'Play lowest spade', action: () => playLowestCard('spades') },
            { key: '2', ctrl: true, shift: true, description: 'Play lowest heart', action: () => playLowestCard('hearts') },
            { key: '3', ctrl: true, shift: true, description: 'Play lowest diamond', action: () => playLowestCard('diamonds') },
            { key: '4', ctrl: true, shift: true, description: 'Play lowest club', action: () => playLowestCard('clubs') },
            
            // General shortcuts
            { key: 'h', alt: true, description: 'Show/hide help', action: () => toggleHelp() },
            { key: 'n', alt: true, description: 'Start new game (if allowed)', action: () => startNewGame() },
            { key: 'i', alt: true, description: 'Repeat last announcement', action: () => repeatLastAnnouncement() },
            { key: 'o', alt: true, description: 'Announce score', action: () => announceScore() },
            { key: 'm', alt: true, description: 'Leave game', action: () => leaveGame() },
        ];

        // Simple number keys for bidding levels
        const bidLevelKeys = ['1', '2', '3', '4', '5', '6', '7'];
        const bidSuitKeys = {
            's': 'S', 
            'h': 'H', 
            'd': 'D', 
            'c': 'C', 
            'n': 'N'  
        };

        // ALL HELPER FUNCTIONS FROM PLAYSOLO (adapted for multiplayer)
        function findLowestCard(cards) {
            if (!cards || cards.length === 0) return null;
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => {
                return cardValues.indexOf(a) - cardValues.indexOf(b);
            });
            
            return sortedCards[0];
        }

        function findHighestCard(cards) {
            if (!cards || cards.length === 0) return null;
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => {
                return cardValues.indexOf(b) - cardValues.indexOf(a);
            });
            
            return sortedCards[0];
        }

        function focusOnLowestCard(position, suit) {
            if (!gameState || !gameState.hands || !gameState.hands[position]) return;
            
            const hand = gameState.hands[position];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) return;
            
            const lowestCard = findLowestCard(cards);
            if (!lowestCard) return;
            
            // Determine which hand element to use
            let handElement = null;
            if (position === myPosition) {
                handElement = elements.southHand; // Our own hand
            } else if (position === gameState.dummy && canViewHandCards(position)) {
                // Find correct hand element for dummy
                if (gameState.dummy === 'north') handElement = elements.northHand;
                else if (gameState.dummy === 'east') handElement = elements.eastHand;
                else if (gameState.dummy === 'west') handElement = elements.westHand;
            }
            
            if (!handElement) return;
            
            const cardButton = handElement.querySelector(`button[data-suit="${suit}"][data-card="${lowestCard}"]`);
            
            if (cardButton) {
                setTimeout(() => {
                    cardButton.focus();
                    console.log(`Focused on ${getSuitName(suit)} ${lowestCard} for player ${position}`);
                }, 250);
            }
        }

        function announceHandSuitWithFocus(position, suit) {
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                const message = `${getPositionName(position)} has no ${getSuitName(suit)}s.`;
                announceToScreenReader(message);
                return;
            }
            
            const message = `${getPositionName(position)}'s ${getSuitName(suit)}s: ${cards.join(', ')}`;
            announceToScreenReader(message);
            
            focusOnLowestCard(position, suit);
        }

        function canViewHandCards(position) {
            if (position === myPosition) return true; // Our own hand
            
            // Dummy is visible if play phase and position is dummy
            if (gameState && 
                gameState.gamePhase === 'play' && 
                gameState.dummy === position) {
                return true;
            }
            
            return false;
        }

        function canPlayFromPosition(position) {
            if (!gameState || gameState.gamePhase !== 'play') return false;
            
            // Can play from our own position
            if (position === myPosition) return true;
            
            // Can play from dummy if we're declarer and position is dummy
            if (position === gameState.dummy && gameState.declarer === myPosition) {
                return true;
            }
            
            return false;
        }

        function isOurTurnToPlay(position) {
            if (!gameState || gameState.gamePhase !== 'play') return false;
            
            const currentPlayer = gameState.currentPlayer;
            
            // Direct control: it's our position and our turn
            if (position === myPosition && currentPlayer === myPosition) return true;
            
            // Dummy control: we're declarer, it's dummy's turn, and we can control dummy
            if (position === gameState.dummy && currentPlayer === gameState.dummy && 
                gameState.declarer === myPosition) {
                return true;
            }
            
            return false;
        }

        function announceEntireHand(position) {
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            let message = `${getPositionName(position)}'s hand: `;
            
            for (const suit of ['spades', 'hearts', 'diamonds', 'clubs']) {
                const cards = hand[suit] || [];
                if (cards.length > 0) {
                    message += `${getSuitName(suit)}s: ${cards.join(', ')}. `;
                } else {
                    message += `No ${getSuitName(suit)}s. `;
                }
            }
            
            announceToScreenReader(message);
        }

        function announceCurrentTrick() {
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader('The game is not in play phase yet.');
                return;
            }
            
            if (!gameState.currentTrick || gameState.currentTrick.length === 0) {
                announceToScreenReader('No cards played in the current trick yet.');
                return;
            }
            
            let message = 'Current trick: ';
            
            for (const card of gameState.currentTrick) {
                message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
            }
            
            announceToScreenReader(message);
        }

        function announceGameState() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            let message = `Game phase: ${gameState.gamePhase}. `;
            
            if (gameState.gamePhase === 'play' || gameState.gamePhase === 'end') {
                message += `Contract: ${formatContract(gameState.contract)} by ${getPositionName(gameState.declarer)}. `;
                message += `North-South tricks: ${gameState.tricks.ns}. East-West tricks: ${gameState.tricks.ew}. `;
                message += `Current player: ${getPositionName(gameState.currentPlayer)}.`;
                
                if (gameState.declarer === myPosition) {
                    message += ` You are the declarer and can control both your position and dummy.`;
                }
            } else if (gameState.gamePhase === 'bidding') {
                message += `Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`;
            }
            
            announceToScreenReader(message);
        }

        function announceCurrentPlayer() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            if (gameState.gamePhase === 'play') {
                let message = `Current player: ${getPositionName(gameState.currentPlayer)}.`;
                
                if (gameState.currentPlayer === gameState.dummy && gameState.declarer === myPosition) {
                    message += ` You control the dummy as the declarer.`;
                }
                
                announceToScreenReader(message);
            } else if (gameState.gamePhase === 'bidding') {
                announceToScreenReader(`Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`);
            } else {
                announceToScreenReader(`Game phase: ${gameState.gamePhase}. No current player.`);
            }
        }

        function announceLastTrick() {
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader('The game is not in play phase yet.');
                return;
            }
            
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                let message = 'Current trick in progress: ';
                for (const card of gameState.currentTrick) {
                    message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
                }
                announceToScreenReader(message);
            } else {
                announceToScreenReader('Previous tricks are not visible - they have been collected. Only the current trick is shown.');
            }
        }

        function makeBidShortcut(bid) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== myPosition) {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            if (!['P', 'X', 'XX'].includes(bid)) {
                announceToScreenReader('Invalid bid format.');
                return;
            }
            
            makeBid(bid);
        }

        function handleBidLevelKey(level) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== myPosition) {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            uiState.bidLevel = level;
            announceToScreenReader(`Bid level ${level} selected. Press S, H, D, C, or N to select suit.`);
        }

        function handleBidSuitKey(suit) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== myPosition || !uiState.bidLevel) {
                if (!uiState.bidLevel) {
                    announceToScreenReader("Please select a bid level 1 through 7 first.");
                } else {
                    announceToScreenReader("It's not your turn to bid.");
                }
                return;
            }
            
            const bid = `${uiState.bidLevel}${suit}`;
            
            if (!isValidBid(bid, biddingState.highestBid)) {
                announceToScreenReader(`Invalid bid: ${uiState.bidLevel} ${getSuitNameForBid(suit)}.`);
                uiState.bidLevel = null;
                return;
            }
            
            makeBid(bid);
            uiState.bidLevel = null;
        }

        function isValidBid(bid, highestBid) {
            if (bid === 'P') return true;
            if (bid === 'X' || bid === 'XX') return true;
            if (!highestBid) return true;
            
            const bidLevel = parseInt(bid.charAt(0));
            const bidSuit = bid.charAt(1);
            const highestLevel = parseInt(highestBid.charAt(0));
            const highestSuit = highestBid.charAt(1);
            
            const suits = ['C', 'D', 'H', 'S', 'N'];
            const bidSuitIndex = suits.indexOf(bidSuit);
            const highestSuitIndex = suits.indexOf(highestSuit);
            
            if (bidLevel > highestLevel) return true;
            if (bidLevel === highestLevel && bidSuitIndex > highestSuitIndex) return true;
            
            return false;
        }

        function getSuitNameForBid(suit) {
            switch(suit) {
                case 'C': return 'Clubs';
                case 'D': return 'Diamonds';
                case 'H': return 'Hearts';
                case 'S': return 'Spades';
                case 'N': return 'No Trump';
                default: return suit;
            }
        }

        function playHighestCard(suit) {
            const currentPlayer = gameState?.currentPlayer;
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader("Game is not in play phase.");
                return;
            }
            
            const canControl = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControl) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            const highestCard = findHighestCard(cards);
            
            if (highestCard) {
                attemptToPlayCard(suit, highestCard, currentPlayer);
            }
        }

        function playLowestCard(suit) {
            const currentPlayer = gameState?.currentPlayer;
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader("Game is not in play phase.");
                return;
            }
            
            const canControl = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControl) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            const lowestCard = findLowestCard(cards);
            
            if (lowestCard) {
                attemptToPlayCard(suit, lowestCard, currentPlayer);
            }
        }

        function announceScore() {
            if (gameState && (gameState.gamePhase === 'play' || gameState.gamePhase === 'end')) {
                announceToScreenReader(`North-South: ${gameState.tricks.ns} tricks. East-West: ${gameState.tricks.ew} tricks.`);
            } else {
                announceToScreenReader("No score available yet.");
            }
        }

        function clearAnnouncementQueue() {
            announcementQueue.clear();
            announceToScreenReader("Announcement queue cleared.");
        }

        function repeatLastAnnouncement() {
            if (uiState.lastAnnouncement) {
                announcementQueue.repeatLast();
            } else {
                announceToScreenReader("No announcement to repeat.");
            }
        }

        function renderHelpList() {
            elements.helpList.innerHTML = '';
            
            keyboardShortcuts.forEach(shortcut => {
                if (!shortcut.action) return;
                
                const modifiers = [];
                if (shortcut.alt) modifiers.push('Alt');
                if (shortcut.shift) modifiers.push('Shift');
                if (shortcut.ctrl) modifiers.push('Ctrl');
                
                const keyCombo = modifiers.length > 0 
                    ? `${modifiers.join('+')} + ${shortcut.key.toUpperCase()}`
                    : shortcut.key.toUpperCase();
                    
                const li = document.createElement('li');
                li.innerHTML = `<strong>${keyCombo}</strong>: ${shortcut.description}`;
                elements.helpList.appendChild(li);
            });
            
            const gamePhase = gameState ? gameState.gamePhase : 'setup';
            const phaseText = gamePhase === 'bidding' ? 'Select suit for bidding' : 
                             gamePhase === 'play' ? 'Focus on lowest card of suit' : 
                             'Depends on game phase';
            
            const dualPurposeKeys = [
                { key: 'S', desc: 'Spades' },
                { key: 'H', desc: 'Hearts' },
                { key: 'D', desc: 'Diamonds' },
                { key: 'C', desc: 'Clubs' }
            ];
            
            dualPurposeKeys.forEach(key => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${key.key}</strong>: ${phaseText} (${key.desc})`;
                elements.helpList.appendChild(li);
            });
            
            if (gamePhase === 'bidding') {
                const li = document.createElement('li');
                li.innerHTML = `<strong>N</strong>: Select No Trump for bidding`;
                elements.helpList.appendChild(li);
            }
        }

        function getPositionName(position) {
            switch(position) {
                case 'north': return 'North';
                case 'east': return 'East';
                case 'south': return 'South';
                case 'west': return 'West';
                default: return position || 'Unknown';
            }
        }

        function getSuitName(suit) {
            const names = {
                spades: 'Spades',
                hearts: 'Hearts',
                diamonds: 'Diamonds',
                clubs: 'Clubs'
            };
            return names[suit] || suit;
        }

        function getSuitSymbol(suit) {
            const symbols = { 
                spades: '♠', 
                hearts: '♥', 
                diamonds: '♦', 
                clubs: '♣' 
            };
            return symbols[suit] || suit;
        }

        // UI FUNCTIONS
        function showHelp() {
            uiState.showHelp = true;
            toggleHelp();
        }
        
        function closeHelp() {
            uiState.showHelp = false;
            toggleHelp();
        }

        function toggleHelp() {
            uiState.showHelp = !uiState.showHelp;
            elements.helpSection.style.display = uiState.showHelp ? 'block' : 'none';
            elements.toggleHelpButton.textContent = uiState.showHelp ? 'Hide Help' : 'Show Help';
            elements.toggleHelpButton.setAttribute('aria-expanded', uiState.showHelp);
            
            if (uiState.showHelp) {
                renderHelpList();
            }
        }
        
        function leaveGame() {
            if(confirm('Are you sure you want to leave the game? You will be replaced by GIB AI.')) {
                socket.emit('leaveGame');
                navigate('/');
            }
        }

        function fullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error entering fullscreen mode: ${err.message}`);
                });
                document.getElementById('fullscreen-button').textContent = 'Exit Fullscreen';
            } else {
                document.exitFullscreen();
                document.getElementById('fullscreen-button').textContent = 'Full Screen';
            }
        }

        function startNewGame() {
            if (!tableCode) return;
            
            socket.emit('startNewGame', { tableCode: tableCode });
            announceToScreenReader('Starting new game...');
        }

        // MULTIPLAYER SPECIFIC FUNCTIONS
        function renderAllHands() {
            if (!gameState || !gameState.hands) return;
            
            for (const position of ['north', 'south', 'east', 'west']) {
                if (gameState.hands[position]) {
                    renderHand(position, gameState.hands[position]);
                }
            }
        }
        
        function renderHand(position, hand) {
            const element = position === 'north' ? document.getElementById('north-hand') :
                           position === 'south' ? document.getElementById('south-hand') :
                           position === 'east' ? document.getElementById('east-hand') :
                           document.getElementById('west-hand');
            
            if (!element || !hand) return;
            
            // Determine player type and title
            let positionType = '';
            let title = '';
            
            if (position === myPosition) {
                title = `Your Hand (${getPositionName(position)})`;
                positionType = '';
            } else {
                title = getPositionName(position);
                if (gameState && position === gameState.dummy && gameState.declarer === myPosition) {
                    positionType = ' (Dummy - You control)';
                } else if (gameState && gameState.players && gameState.players[position] && gameState.players[position].type === 'gib') {
                    positionType = ' (GIB)';
                } else {
                    positionType = ' (Human)';
                }
            }
            
            let html = `<h3>${title}${positionType}</h3>`;
            
            // Check if we can view cards
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                html += `<p>Cards will be visible when play begins, if you are declarer or dummy.</p>`;
                element.innerHTML = html;
                return;
            }
            
            const canPlayFromThisPosition = canPlayFromPosition(position);
            const isPlayPhase = gameState && gameState.gamePhase === 'play';
            
            Object.entries(hand).forEach(([suit, cards]) => {
                const suitClass = `suit-${suit}`;
                
                html += `
                    <div class="suit-row">
                        <div class="suit-label ${suitClass}">
                            ${getSuitSymbol(suit)} ${getSuitName(suit)}
                        </div>
                        <div class="cards-buttons">
                `;
                
                if (cards.length > 0) {
                    cards.forEach(card => {
                        const cardClass = `card-${suit}`;
                        
                        if (isPlayPhase && canPlayFromThisPosition) {
                            html += `
                                <button 
                                    class="card-button ${cardClass}"
                                    data-suit="${suit}"
                                    data-card="${card}"
                                    onclick="attemptToPlayCard('${suit}', '${card}', '${position}')"
                                    aria-label="Play ${getSuitName(suit)} ${card}"
                                >
                                    ${card}
                                </button>
                            `;
                        } else {
                            html += `
                                <span class="card-display ${cardClass}" aria-label="${getSuitName(suit)} ${card}">
                                    ${card}
                                </span>
                            `;
                        }
                    });
                } else {
                    html += `<span class="text-gray-400">(empty)</span>`;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            element.innerHTML = html;
        }
        
        // BIDDING FUNCTIONS (same as original)
        function renderBiddingUI() {
            const biddingArea = document.getElementById('bidding-area');
            if (biddingArea) {
                biddingArea.style.display = 'block';
            }
            
            renderBiddingHistory();
            
            if (biddingState && biddingState.currentBidder === myPosition) {
                renderBiddingControls();
            } else {
                const biddingControls = document.getElementById('bidding-controls');
                if (biddingControls) {
                    biddingControls.innerHTML = `
                        <h3>Your Bid</h3>
                        <p>Waiting for ${positionName(biddingState ? biddingState.currentBidder : 'unknown')} to bid...</p>
                    `;
                }
            }
        }
        
        function renderBiddingHistory() {
            const biddingHistory = document.getElementById('bidding-history');
            if (!biddingHistory) return;
            
            let html = '<h3>Bidding History</h3>';
            
            if (!biddingState || !biddingState.bidHistory || biddingState.bidHistory.length === 0) {
                html += '<p>No bids yet.</p>';
            } else {
                html += `
                    <table class="bidding-table">
                        <thead>
                            <tr>
                                <th>West</th>
                                <th>North</th>
                                <th>East</th>
                                <th>South</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                const rounds = [];
                let currentRound = [];
                let dealerIndex = ['west', 'north', 'east', 'south'].indexOf(biddingState.dealer || 'south');
                
                for (let i = 0; i < dealerIndex; i++) {
                    currentRound.push(null);
                }
                
                for (const bid of biddingState.bidHistory) {
                    currentRound.push(bid);
                    
                    if (currentRound.length === 4) {
                        rounds.push([...currentRound]);
                        currentRound = [];
                    }
                }
                
                if (currentRound.length > 0) {
                    rounds.push([...currentRound]);
                }
                
                for (const round of rounds) {
                    html += '<tr>';
                    
                    for (let i = 0; i < 4; i++) {
                        const bid = round[i];
                        
                        if (!bid) {
                            html += '<td></td>';
                        } else {
                            const bidText = formatBidForDisplay(bid.bid);
                            html += `<td>${bidText}</td>`;
                        }
                    }
                    
                    html += '</tr>';
                }
                
                html += '</tbody></table>';
            }
            
            biddingHistory.innerHTML = html;
        }
        
        function renderBiddingControls() {
            const biddingControls = document.getElementById('bidding-controls');
            if (!biddingControls) return;
            
            const possibleBids = getPossibleBids(biddingState ? biddingState.highestBid : null);
            
            let html = '<h3>Your Bid</h3>';
            html += '<div class="bidding-buttons">';
            
            for (const specialBid of ['P', 'X', 'XX']) {
                if (possibleBids.includes(specialBid)) {
                    const bidText = specialBid === 'P' ? 'Pass' : 
                                  specialBid === 'X' ? 'Double (X)' : 'Redouble (XX)';
                    
                    html += `
                        <button class="bid-button" onclick="makeBid('${specialBid}')">
                            ${bidText}
                        </button>
                    `;
                }
            }
            
            const contractBids = possibleBids.filter(bid => !['P', 'X', 'XX'].includes(bid));
            const bidsByLevel = {};
            
            for (const bid of contractBids) {
                const level = bid.charAt(0);
                if (!bidsByLevel[level]) bidsByLevel[level] = [];
                bidsByLevel[level].push(bid);
            }
            
            for (const level in bidsByLevel) {
                html += `<div class="bid-level-group">`;
                
                for (const bid of bidsByLevel[level]) {
                    const suit = bid.charAt(1);
                    let suitSymbol, suitClass;
                    
                    switch(suit) {
                        case 'C': 
                            suitSymbol = '♣'; 
                            suitClass = 'bid-clubs';
                            break;
                        case 'D': 
                            suitSymbol = '♦'; 
                            suitClass = 'bid-diamonds';
                            break;
                        case 'H': 
                            suitSymbol = '♥'; 
                            suitClass = 'bid-hearts';
                            break;
                        case 'S': 
                            suitSymbol = '♠'; 
                            suitClass = 'bid-spades';
                            break;
                        case 'N': 
                            suitSymbol = 'NT'; 
                            suitClass = 'bid-notrump';
                            break;
                        default: 
                            suitSymbol = suit;
                            suitClass = '';
                    }
                    
                    html += `
                        <button class="bid-button ${suitClass}" onclick="makeBid('${bid}')">
                            ${level}${suitSymbol}
                        </button>
                    `;
                }
                
                html += `</div>`;
            }
            
            html += '</div>';
            html += '<div class="bid-meanings">';
            html += `<p><strong>System:</strong> Natural</p>`;
            html += '</div>';
            
            biddingControls.innerHTML = html;
        }
        
        function makeBid(bid) {
            if (!tableCode) return;
            
            socket.emit('makeBid', {
                tableCode: tableCode,
                position: myPosition,
                bid: bid
            });
        }
        
        function getPossibleBids(highestBid) {
            const possibleBids = ['P'];
            
            if (highestBid) {
                possibleBids.push('X');
            }
            
            const levels = ['1', '2', '3', '4', '5', '6', '7'];
            const suits = ['C', 'D', 'H', 'S', 'N'];
            
            if (!highestBid) {
                for (const level of levels) {
                    for (const suit of suits) {
                        possibleBids.push(`${level}${suit}`);
                    }
                }
            } else {
                const highestLevel = parseInt(highestBid.charAt(0));
                const highestSuit = highestBid.charAt(1);
                const highestSuitIndex = suits.indexOf(highestSuit);
                
                for (let level = highestLevel; level <= 7; level++) {
                    for (let suitIndex = 0; suitIndex < suits.length; suitIndex++) {
                        if (level === highestLevel && suitIndex <= highestSuitIndex) continue;
                        possibleBids.push(`${level}${suits[suitIndex]}`);
                    }
                }
            }
            
            return possibleBids;
        }
        
        function formatBidForDisplay(bid) {
            if (bid === 'P') return 'Pass';
            if (bid === 'X') return 'X (Double)';
            if (bid === 'XX') return 'XX (Redouble)';
            
            const level = bid.charAt(0);
            const suit = bid.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            return `${level}${suitSymbol}`;
        }
        
        function updateGameUI() {
            if (!gameState) return;
            
            const playersArea = document.getElementById('players-area');
            if (playersArea) {
                let html = '';
                
                const positions = ['north', 'east', 'south', 'west'];
                for (const position of positions) {
                    const isCurrentPlayer = gameState.currentPlayer === position;
                    const player = gameState.players[position];
                    const playerName = player ? player.name : positionName(position);
                    let playerType = player ? player.type : 'human';
                    
                    if (position === gameState.dummy && gameState.declarer === myPosition) {
                        playerType = 'Dummy (You control)';
                    } else if (playerType === 'gib') {
                        playerType = 'GIB';
                    } else {
                        playerType = 'Human';
                    }
                    
                    // Highlight our own position
                    const isOurPosition = position === myPosition;
                    
                    html += `
                        <div class="player-badge ${isCurrentPlayer ? 'current' : ''} ${isOurPosition ? 'our-position' : ''}">
                            <div>${positionName(position)}</div>
                            <div>${playerName}</div>
                            <div>${playerType}</div>
                        </div>
                    `;
                }
                
                playersArea.innerHTML = html;
            }
            
            const statusArea = document.getElementById('status-area');
            if (statusArea) {
                if (gameState.gamePhase === 'bidding') {
                    statusArea.textContent = 'Bidding phase';
                } else if (gameState.gamePhase === 'play') {
                    let statusText = `Playing: ${formatContract(gameState.contract)}`;
                    if (gameState.declarer === myPosition) {
                        statusText += ' (You are declarer)';
                    }
                    statusArea.textContent = statusText;
                } else {
                    statusArea.textContent = 'BridgeCircle Multiplayer';
                }
            }
        }
        
        function formatContract(contract) {
            if (!contract) return "No contract";
            
            const level = contract.charAt(0);
            const suit = contract.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            let result = `${level}${suitSymbol}`;
            
            if (contract.includes('XX')) {
                result += ' XX';
            } else if (contract.includes('X')) {
                result += ' X';
            }
            
            return result;
        }
        
        function updateCenterArea() {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.gamePhase === 'play') {
                let html = '<h3>Played Tricks</h3>';
                
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
                
                if (gameState.contract) {
                    html += `<p>Contract: ${formatContract(gameState.contract)}, `;
                    html += `declarer: ${positionName(gameState.declarer)}</p>`;
                }
                
                centerArea.innerHTML = html;
            }
        }
        
        function updatePlayedCard(position, suit, card) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.currentTrick && gameState.currentTrick.length === 1) {
                centerArea.innerHTML = '<h3>Current Trick</h3>';
            }
            
            const cardElement = document.createElement('div');
            cardElement.className = `played-card ${suit === 'hearts' || suit === 'diamonds' ? 'red-card' : ''}`;
            cardElement.innerHTML = `<span class="player-name">${positionName(position)}:</span> ${getSuitSymbol(suit)} ${card}`;
            
            centerArea.appendChild(cardElement);
        }
        
        function showGameOver(message) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            let html = '<h3>Game Over</h3>';
            html += `<p>${message}</p>`;
            
            if (gameState && gameState.tricks) {
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
            }
            
            html += `<button onclick="startNewGame()" class="button">Start New Game</button>`;
            
            centerArea.innerHTML = html;
            
            // Show new game button
            elements.newGameButton.style.display = 'block';
        }

        function updatePlayedCardsContainer() {
            const container = elements.playedCardsContainer;
            if (!container) return;
            
            if (!gameState || !gameState.currentTrick || gameState.currentTrick.length === 0) {
                container.innerHTML = '<p class="text-gray-500">No cards played in current trick yet.</p>';
                return;
            }
            
            let html = '<div class="current-trick-display">';
            html += '<h3>Current Trick</h3>';
            html += '<div class="trick-cards">';
            
            for (const card of gameState.currentTrick) {
                const suitColor = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'red-card' : 'black-card';
                html += `
                    <div class="played-card-item ${suitColor}">
                        <span class="player-name">${positionName(card.player)}:</span>
                        <span class="card-display">${getSuitSymbol(card.suit)}${card.card}</span>
                    </div>
                `;
            }
            
            html += '</div>';
            
            const cardsRemaining = 4 - gameState.currentTrick.length;
            if (cardsRemaining > 0) {
                html += `<p class="trick-status">${cardsRemaining} more card${cardsRemaining > 1 ? 's' : ''} needed to complete trick.</p>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function resetPlayedCardsContainer() {
            const container = elements.playedCardsContainer;
            if (container) {
                container.innerHTML = '<p class="text-gray-500">No cards played in current trick yet.</p>';
            }
        }

        // CHAT FUNCTIONS
        function sendChatMessage() {
            const message = document.getElementById('chat-input').value.trim();
            if (!message || !tableCode) return;
            
            socket.emit('sendChatMessage', {
                tableCode: tableCode,
                message: message
            });
            
            document.getElementById('chat-input').value = '';
        }
        
        function addChatMessage(sender, position, message) {
            const chatArea = document.getElementById('chat-messages');
            if (!chatArea) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message';
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageElement.innerHTML = `
                <span class="chat-sender">${sender} (${positionName(position)}):</span>
                <span class="chat-time">[${timestamp}]</span>
                <div class="chat-text">${message}</div>
            `;
            
            chatArea.appendChild(messageElement);
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        function addSystemMessage(message) {
            const chatArea = document.getElementById('chat-messages');
            if (!chatArea) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message system-message';
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageElement.innerHTML = `
                <span class="chat-time">[${timestamp}]</span>
                <div class="chat-text">${message}</div>
            `;
            
            chatArea.appendChild(messageElement);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // KEYBOARD SETUP
        function setupKeyboardListeners() {
            document.addEventListener('keydown', (e) => {
                for (const shortcut of keyboardShortcuts) {
                    if (shortcut.action && 
                        e.key.toLowerCase() === shortcut.key.toLowerCase() && 
                        (!shortcut.alt || e.altKey) && 
                        (!shortcut.shift || e.shiftKey) && 
                        (!shortcut.ctrl || e.ctrlKey)) {
                        
                        e.preventDefault();
                        shortcut.action();
                        return;
                    }
                }
                
                const suitKey = e.key.toLowerCase();
                if (['s', 'h', 'd', 'c'].includes(suitKey) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    
                    if (gameState && gameState.gamePhase === 'bidding') {
                        if (suitKey in bidSuitKeys) {
                            handleBidSuitKey(bidSuitKeys[suitKey]);
                        }
                    }
                    return;
                }
                
                if (bidLevelKeys.includes(e.key) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    handleBidLevelKey(e.key);
                    return;
                }
                
                if (e.key.toLowerCase() === 'n' && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    if (gameState && gameState.gamePhase === 'bidding') {
                        handleBidSuitKey('N');
                    }
                    return;
                }
            });
        }
        
        function navigate(page) {
            window.location.href = page;
        }
        
        function initializeGameView() {
            socket.emit('joinGame', { tableCode: tableCode });
        }
        
        // MAIN INITIALIZATION
        document.addEventListener('DOMContentLoaded', function() {
            setupKeyboardListeners();
            connectToServer();
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code')) {
                tableCode = urlParams.get('code');
                
                document.getElementById('table-code-title').textContent = tableCode;
                initializeGameView();
            } else {
                navigate('/');
            }
            
            // SOCKET EVENT HANDLERS
            socket.on('yourCards', (data) => {
                myPosition = data.position;
                if (!gameState) gameState = {};
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                renderHand(data.position, data.cards);
            });
            
            socket.on('bidMade', (data) => {
                biddingState = data.biddingState;
                renderBiddingUI();
                
                const bidText = data.bid === 'P' ? 'passes' : 
                              data.bid === 'X' ? 'doubles' : 
                              data.bid === 'XX' ? 'redoubles' : `bids ${formatBidForDisplay(data.bid)}`;
                announceToScreenReader(`${positionName(data.position)} ${bidText}.`);
            });
            
            socket.on('biddingComplete', (data) => {
                gameState.contract = data.contract;
                gameState.declarer = data.declarer;
                gameState.dummy = data.dummy;
                gameState.trumpSuit = data.trumpSuit;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gamePhase = 'play';
                
                if (biddingState) {
                    biddingState.biddingComplete = true;
                }
                
                document.getElementById('bidding-area').style.display = 'none';
                updateGameUI();
                renderAllHands();
                
                const contractMessage = `Final contract: ${formatContract(data.contract)} by ${positionName(data.declarer)}. ${positionName(data.currentPlayer)} leads.`;
                
                if (data.declarer === myPosition) {
                    const dummyMessage = ` You are the declarer and control both your position and dummy.`;
                    announceToScreenReader(contractMessage + dummyMessage);
                } else {
                    announceToScreenReader(contractMessage);
                }
            });
            
            socket.on('playPhaseCards', (data) => {
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                
                if (data.dummyCards) {
                    gameState.hands[gameState.dummy] = data.dummyCards;
                    announceToScreenReader(`Dummy's cards are now visible.`);
                }
                
                renderAllHands();
            });
            
            socket.on('cardPlayed', (data) => {
                if (trickClearTimeout) {
                    clearTimeout(trickClearTimeout);
                    trickClearTimeout = null;
                }
                
                if (!gameState.currentTrick) gameState.currentTrick = [];
                
                gameState.currentTrick = data.currentTrick;
                
                if (gameState.hands[data.position]) {
                    const suitCards = gameState.hands[data.position][data.suit];
                    if (suitCards) {
                        const index = suitCards.indexOf(data.card);
                        if (index > -1) {
                            suitCards.splice(index, 1);
                        }
                    }
                }
                
                renderHand(data.position, gameState.hands[data.position]);
                updatePlayedCard(data.position, data.suit, data.card);
                updatePlayedCardsContainer();
                
                announceToScreenReader(`${positionName(data.position)} played ${getSuitName(data.suit)} ${data.card}`);
            });

            socket.on('trickComplete', (data) => {
                gameState.currentTrick = [];
                gameState.tricks = data.tricks;
                gameState.currentPlayer = data.nextPlayer;
                
                updateCenterArea();
                updateGameUI();
                
                const winner = positionName(data.winner);
                const next = positionName(data.nextPlayer);
                
                const isUserNext = (data.nextPlayer === myPosition) || 
                                 (data.nextPlayer === gameState.dummy && gameState.declarer === myPosition);
                
                let message;
                if (isUserNext) {
                    message = `${winner} won the trick. Your turn to play a card.`;
                } else {
                    message = `${winner} won the trick. ${next} plays next.`;
                }
                
                announceToScreenReader(message);

                if (trickClearTimeout) {
                    clearTimeout(trickClearTimeout);
                }

                trickClearTimeout = setTimeout(() => {
                    resetPlayedCardsContainer();
                    trickClearTimeout = null;
                }, 3000);
            });
            
            socket.on('nextPlayer', (data) => {
                gameState.currentPlayer = data.currentPlayer;
                updateGameUI();
                renderAllHands();
            });

            socket.on('gameOver', (data) => {
                gameState.gamePhase = 'end';
                gameState.tricks = data.tricks;
                
                showGameOver(data.message);
                announceToScreenReader(data.message);
            });
            
            socket.on('chatMessage', (data) => {
                addChatMessage(data.sender, data.position, data.message);
            });
            
            socket.on('playerReplaced', (data) => {
                gameState.players = data.table.players;
                updateGameUI();
                addSystemMessage(`Player at ${data.position} was replaced by GIB.`);
            });

            socket.on('gameStarted', (data) => {
                gameState = data.gameState || {};
                biddingState = data.biddingState || {};
                
                gameState.gamePhase = 'bidding';
                updateGameUI();
                renderBiddingUI();

                resetPlayedCardsContainer();
                announceToScreenReader('Game started. Bidding phase begins.');
            });

            socket.on('dummyRevealed', (data) => {
                if (gameState && data.dummyCards && data.dummyPosition) {
                    if (!gameState.hands) gameState.hands = {};
                    gameState.hands[data.dummyPosition] = data.dummyCards;
                    renderHand(data.dummyPosition, data.dummyCards);
                    announceToScreenReader(`Dummy cards revealed: ${positionName(data.dummyPosition)}.`);
                }
            });
            
            // Chat input handler
            document.getElementById('chat-input').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    sendChatMessage();
                }
            });
        });
    </script>
</body>
</html>