<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AccessibleBridge</title>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/multiplayer.css">
    <meta name="description" content="Bridge multiplayer game">
</head>
<body>
    <div class="container" id="multiplayer-app">
        <h1 id="main-title">AccessibleBridge</h1>
        
        <div id="status-announcer" aria-live="polite" class="sr-only"></div>
        
        <div id="error-area" class="error-message" style="display: none;"></div>
        
        <div id="status-area" role="status">Welcome</div>
        
        <div id="main-action-buttons">
            <button onclick="toggleHelp()" id="toggle-help-button" aria-expanded="false">Help</button>
            <button onclick="navigate('/')" id="back-button">Back</button>
        </div>
        
        <section id="help-section" style="display: none;" role="dialog" aria-labelledby="help-title">
            <h2 id="help-title" tabindex="-1">Shortcuts</h2>
            <div class="help-content">
                <ul id="help-list"></ul>
            </div>
            <button onclick="closeHelp()" id="close-help-button">Close</button>
        </section>

        <div id="start-menu-view">
            <h2>Multiplayer Bridge</h2>
            <button onclick="showCreateTable()">Create Table</button>
            <button onclick="showJoinTable()">Join Table</button>
        </div>

        <div id="create-table-view" style="display: none;">
            <h2>Create Table</h2>
            
            <form id="create-table-form" action="javascript:void(0);">
                <label for="create-name-input">Name:</label>
                <input type="text" id="create-name-input" placeholder="Your name" required maxlength="50" autocomplete="username">
                
                <fieldset>
                    <legend>Position:</legend>
                    <div role="radiogroup" aria-label="Choose position">
                        <button type="button" id="create-pos-north" role="radio" aria-checked="false" onclick="selectCreatePosition('north')">North</button>
                        <button type="button" id="create-pos-east" role="radio" aria-checked="false" onclick="selectCreatePosition('east')">East</button>
                        <button type="button" id="create-pos-south" role="radio" aria-checked="true" onclick="selectCreatePosition('south')">South</button>
                        <button type="button" id="create-pos-west" role="radio" aria-checked="false" onclick="selectCreatePosition('west')">West</button>
                    </div>
                    <p><strong>Selected:</strong> <span id="create-selected-position-name">South</span></p>
                </fieldset>
                
                <label for="table-name-input">Table Name (optional):</label>
                <input type="text" id="table-name-input" placeholder="Table name" maxlength="100">
                
                <button type="submit" onclick="createTable()" id="create-table-button">Create</button>
                <button type="button" onclick="showStartMenu()">Back</button>
                
                <div id="creation-status" style="display: none;"></div>
            </form>
        </div>

        <div id="join-table-view" style="display: none;">
            <h2>Join Table</h2>
            
            <form id="join-table-form" action="javascript:void(0);">
                <label for="join-name-input">Name:</label>
                <input type="text" id="join-name-input" placeholder="Your name" required maxlength="50" autocomplete="username">
                
                <label for="table-code-input">Table Code:</label>
                <input type="text" id="table-code-input" placeholder="4-digit code" required maxlength="4" pattern="[0-9]{4}" inputmode="numeric">
                
                <button type="submit" onclick="joinTable()" id="join-table-button">Join</button>
                <button type="button" onclick="showStartMenu()">Back</button>
            </form>
        </div>

        <div id="position-selection-view" style="display: none;">
            <h2>Select Position</h2>
            <p>Table: <strong id="join-table-code-display"></strong></p>
            <p id="join-table-status">Loading...</p>
            
            <div id="join-available-positions-container" role="radiogroup" aria-label="Available positions"></div>
            <button onclick="cancelJoin()">Cancel</button>
        </div>

        <div id="waiting-room-view" style="display: none;">
            <h2>Table <span id="waiting-table-code-title"></span></h2>
            
            <p>Share code: <strong id="share-table-code"></strong> <button onclick="copyTableCode()" id="copy-code-button">Copy</button></p>
            
            <div role="group" aria-label="Players">
                <div id="waiting-position-north" role="group">
                    <h4>North</h4>
                    <p class="player-name" aria-live="polite">Waiting...</p>
                </div>
                <div id="waiting-position-east" role="group">
                    <h4>East</h4>
                    <p class="player-name" aria-live="polite">Waiting...</p>
                </div>
                <div id="waiting-position-south" role="group">
                    <h4>South</h4>
                    <p class="player-name" aria-live="polite">Waiting...</p>
                </div>
                <div id="waiting-position-west" role="group">
                    <h4>West</h4>
                    <p class="player-name" aria-live="polite">Waiting...</p>
                </div>
            </div>
            
            <p>Players: <span id="waiting-player-count">0</span>/4</p>

            <button onclick="startGameFromWaiting()" id="start-game-button" disabled>Start Game</button>
            <button onclick="leaveTableFromWaiting()">Leave</button>

            <div>
                <input type="checkbox" id="aanetKaytossa">
                <label for="aanetKaytossa">Sounds</label>
                <span id="aaniStatus" role="status" aria-live="polite">Disabled</span>
            </div>
            
            <div>
                <input type="checkbox" id="useSynthesizer">
                <label for="useSynthesizer">Use synthesizer</label>
                <span id="synthStatus" role="status" aria-live="polite">Disabled</span>
            </div>
            
            <div>
                <h3>Chat</h3>
                <div id="waiting-chat-messages" aria-live="polite"></div>
                <input type="text" id="waiting-chat-input" placeholder="Message..." aria-label="Chat message">
                <button onclick="sendWaitingChatMessage()" id="waiting-send-chat-button">Send</button>
            </div>
        </div>

        <div id="game-view" style="display: none;">
            <div id="game-header">
                <div id="deal-info-area">
                    <span>Deal: <span id="deal-number">1</span></span>
                    <span>Dealer: <span id="current-dealer">South</span></span>
                </div>
                <div id="score-area">
                    <span id="ns-score">NS 0/13</span>
                    <span id="ew-score">EW 0/13</span>
                </div>
            </div>
            
           
            <div id="top-position-area" class="position-area">
                </div>
            
            <div id="middle-row">
                <div id="left-position-area" class="position-area side-position">
                    </div>
                
<div id="play-area">
    <section id="game-bidding-area" style="display: none;">
        <h2>Bidding</h2>
        <div id="game-bidding-history">
            <h3>History</h3>
            <p>No bids yet.</p>
        </div>
        <div id="game-bidding-controls">
            <h3>Your Bid</h3>
            <p>Waiting...</p>
        </div>
    </section>
    
    <div id="contract-info" style="display: none;">
        <span id="contract-display"></span>
        <span id="declarer-info"></span>
    </div>
    
    <div id="current-trick-area">
        <div id="game-played-cards-container">
            <p>No cards played yet.</p>
        </div>
    </div>
</div>
                
                <div id="right-position-area" class="position-area side-position">
                    </div>
            </div>
            
            <div id="bottom-position-area" class="position-area player-position">
                </div>
            
            <div id="game-controls">
                <button onclick="startNewGameFromGame()" id="game-new-game-button" style="display: none;">New Game</button>
                <button onclick="leaveGameFromGame()">Leave Game</button>
            </div>
           
            <div id="game-chat-area">
                <h3>Chat</h3>
                <div id="game-chat-messages" aria-live="polite"></div>
                <input type="text" id="game-chat-input" placeholder="Message..." aria-label="Chat message">
                <button onclick="sendGameChatMessage()">Send</button>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // GLOBAL STATE
        let aanetAlustettu = false;
        let useSynthesizerEnabled = false;
        let speechSynthesis = window.speechSynthesis;
        const sounds = {
            deal: new Howl({ src: ['/deal.mp3'], volume: 0.5 }),
            hit: new Howl({ src: ['/hit.mp3'], volume: 0.5 })
        };

        let dealNumber = 1;
        let currentDealer = 'south';
        let autoDealTimeout = null;
        let currentView = 'start-menu';
        let tableCode = null;
        let gameState = null;
        let biddingState = null;
        let myPosition = null;
        let myName = null;
        let selectedCreatePosition = 'south';
        let selectedJoinPosition = null;
        let availableJoinPositions = [];
        let lastAnnouncementTime = 0;
        let socket = null;

        const uiState = {
            showHelp: false,
            lastAnnouncement: '',
            bidLevel: null,
        };

        // ANNOUNCEMENT SYSTEM
        const announcementQueue = {
            queue: [],
            processing: false,
            currentTimeout: null,

            add(message) {
                uiState.lastAnnouncement = message;
                this.queue.push({
                    message: message,
                    timestamp: Date.now(),
                    estimatedDuration: Math.max(100, Math.min(500, message.length * 0))
                });

                if (!this.processing) {
                    this.processNext();
                }
            },

            processNext() {
                if (this.queue.length === 0) {
                    this.processing = false;
                    return;
                }

                this.processing = true;
                const announcement = this.queue.shift();
                document.getElementById('status-announcer').textContent = '';

                setTimeout(() => {
                    document.getElementById('status-announcer').textContent = announcement.message;
                    speakMessage(announcement.message);
                    this.currentTimeout = setTimeout(() => {
                        this.processNext();
                    }, announcement.estimatedDuration);
                }, 0);
            },

            clear() {
                this.queue = [];
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                document.getElementById('status-announcer').textContent = '';
                this.processing = false;
            },

            repeatLast() {
                if (uiState.lastAnnouncement) {
                    this.clear();
                    this.add(uiState.lastAnnouncement);
                }
            }
        };


        // SPEECH SYNTHESIS FUNCTION
        function speakMessage(message) {
            if (!useSynthesizerEnabled || !speechSynthesis) {
                return;
            }
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.lang = 'en-US';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            // Speak the message
            speechSynthesis.speak(utterance);
        }
        function announceToScreenReader(message) {
            announcementQueue.add(message);
        }

        function showErrorWithAnnouncement(message) {
            showError(message);
            announceToScreenReader(message);
        }

        // SOCKET CONNECTION
        function connectToServer() {
            if (socket && socket.connected) {
                console.log('Socket already connected');
                return socket;
            }
            
            console.log('Creating new socket connection...');
            
            socket = io({
                transports: ['websocket', 'polling'],
                timeout: 10000,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5
            });
            
            return socket;
        }

        // VIEW MANAGEMENT
        function showView(viewName) {
            const views = ['start-menu-view', 'create-table-view', 'join-table-view', 
                          'position-selection-view', 'waiting-room-view', 'game-view'];
            
            views.forEach(view => {
                const element = document.getElementById(view);
                if (element) {
                    element.style.display = 'none';
                }
            });
            
            const viewElement = document.getElementById(viewName);
            if (viewElement) {
                viewElement.style.display = 'block';
                currentView = viewName.replace('-view', '');
                updateTitle();
                updateHelpContent();
                updateStatus();
                updateActionButtons();
            }
        }

        function updateTitle() {
            const mainTitle = document.getElementById('main-title');
            const titles = {
                'start-menu': 'AccessibleBridge',
                'create-table': 'Create Table',
                'join-table': 'Join Table',
                'position-selection': 'Select Position',
                'waiting-room': `Table ${tableCode}`,
                'game': `Game ${tableCode}`
            };
            mainTitle.textContent = titles[currentView] || 'AccessibleBridge';
        }

        function updateActionButtons() {
            const backButton = document.getElementById('back-button');
            
            const actions = {
                'start-menu': { text: 'Back to Lobby', action: () => navigate('/') },
                'create-table': { text: 'Back', action: () => showStartMenu() },
                'join-table': { text: 'Back', action: () => showStartMenu() },
                'position-selection': { text: 'Cancel', action: () => cancelJoin() },
                'waiting-room': { text: 'Leave', action: () => leaveTableFromWaiting() },
                'game': { text: 'Leave', action: () => leaveGameFromGame() }
            };
            
            const action = actions[currentView];
            if (action) {
                backButton.textContent = action.text;
                backButton.onclick = action.action;
            }
        }

        function showStartMenu() {
            showView('start-menu-view');
            resetState();
        }

        function showCreateTable() {
            showView('create-table-view');
            
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                document.getElementById('create-name-input').value = savedName;
            }
            
            selectCreatePosition('south');
            setTimeout(() => document.getElementById('create-name-input').focus(), 100);
        }

        function showJoinTable() {
            showView('join-table-view');
            
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                document.getElementById('join-name-input').value = savedName;
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code')) {
                document.getElementById('table-code-input').value = urlParams.get('code');
            }
            
            setTimeout(() => {
                if (document.getElementById('join-name-input').value) {
                    document.getElementById('table-code-input').focus();
                } else {
                    document.getElementById('join-name-input').focus();
                }
            }, 100);
        }

        function showWaitingRoom() {
            showView('waiting-room-view');
            document.getElementById('waiting-table-code-title').textContent = tableCode;
            document.getElementById('share-table-code').textContent = tableCode;
        }

        function showGameView() {
            showView('game-view');
        }

        function updateStatus() {
            const statusArea = document.getElementById('status-area');
            
            const statusTexts = {
                'start-menu': 'Welcome to AccessibleBridge',
                'create-table': 'Create a new table',
                'join-table': 'Join existing table',
                'position-selection': 'Select your position',
                'waiting-room': () => {
                    const playerCount = parseInt(document.getElementById('waiting-player-count').textContent);
                    return playerCount === 4 ? 'Ready to start!' : `Waiting for ${4 - playerCount} more players`;
                },
                'game': () => {
                    if (gameState) {
                        if (gameState.gamePhase === 'bidding') return 'Bidding phase';
                        if (gameState.gamePhase === 'play') {
                            let status = `Playing: ${formatContract(gameState.contract)}`;
                            if (gameState.declarer === myPosition) status += ' (You are declarer)';
                            return status;
                        }
                    }
                    return 'Bridge Game';
                }
            };
            
            const statusText = statusTexts[currentView];
            statusArea.textContent = typeof statusText === 'function' ? statusText() : statusText || 'AccessibleBridge';
        }

        // CREATE TABLE
        function selectCreatePosition(position) {
            ['north', 'east', 'south', 'west'].forEach(pos => {
                const elem = document.getElementById(`create-pos-${pos}`);
                if (elem) {
                    elem.classList.remove('selected');
                    elem.setAttribute('aria-checked', 'false');
                }
            });
            
            const selectedElement = document.getElementById(`create-pos-${position}`);
            if (selectedElement) {
                selectedElement.classList.add('selected');
                selectedElement.setAttribute('aria-checked', 'true');
                selectedCreatePosition = position;
                
                document.getElementById('create-selected-position-name').textContent = positionName(position);
                announceToScreenReader(`Selected: ${positionName(position)}`);
            }
        }

        function createTable() {
            const name = document.getElementById('create-name-input').value.trim();
            const tableName = document.getElementById('table-name-input').value.trim();
            
            if (!name || name.length < 2) {
                showErrorWithAnnouncement('Name required (2+ characters)');
                return;
            }
            
            localStorage.setItem('playerName', name);
            myName = name;
            myPosition = selectedCreatePosition;
            
            document.getElementById('create-table-button').disabled = true;
            document.getElementById('create-table-button').textContent = 'Creating...';
            document.getElementById('creation-status').style.display = 'block';
            document.getElementById('creation-status').textContent = 'Creating...';
            
            if (!socket || !socket.connected) connectToServer();
            
            if (socket) {
                socket.emit('createTable', {
                    playerName: name,
                    position: selectedCreatePosition,
                    tableName: tableName || null
                });
            } else {
                showErrorWithAnnouncement('Connection failed');
                resetCreateTableUI();
            }
        }

        function resetCreateTableUI() {
            document.getElementById('create-table-button').disabled = false;
            document.getElementById('create-table-button').textContent = 'Create';
            document.getElementById('creation-status').style.display = 'none';
        }

        // JOIN TABLE
        function joinTable() {
            const name = document.getElementById('join-name-input').value.trim();
            const code = document.getElementById('table-code-input').value.trim();
            
            if (!name || name.length < 2) {
                showErrorWithAnnouncement('Name required (2+ characters)');
                return;
            }
            
            if (!/^\d{4}$/.test(code)) {
                showErrorWithAnnouncement('Code must be 4 digits');
                return;
            }
            
            localStorage.setItem('playerName', name);
            myName = name;
            
            document.getElementById('join-table-button').disabled = true;
            document.getElementById('join-table-button').textContent = 'Joining...';
            
            if (!socket || !socket.connected) connectToServer();
            
            if (socket) {
                socket.emit('getTableInfo', { tableCode: code, playerName: name });  
            } else {
                showErrorWithAnnouncement('Connection failed');
                resetJoinTableUI();
            }
        }

        function resetJoinTableUI() {
            document.getElementById('join-table-button').disabled = false;
            document.getElementById('join-table-button').textContent = 'Join';
        }

        function showPositionSelection(code, positions, tableInfo) {
            tableCode = code;
            availableJoinPositions = positions;
            
            showView('position-selection-view');
            
            document.getElementById('join-table-code-display').textContent = code;
            
            const playerCount = Object.values(tableInfo.players || {}).filter(p => p !== null).length;
            document.getElementById('join-table-status').textContent = 
                `${playerCount}/4 players. Choose position:`;
            
            const container = document.getElementById('join-available-positions-container');
            container.innerHTML = '';
            
            positions.forEach(position => {
                const button = document.createElement('button');
                button.textContent = positionName(position);
                button.setAttribute('role', 'radio');
                button.setAttribute('aria-checked', 'false');
                button.onclick = () => selectJoinPosition(position);
                container.appendChild(button);
            });
            
            setTimeout(() => {
                const firstButton = container.querySelector('button');
                if (firstButton) firstButton.focus();
            }, 100);
        }

        function selectJoinPosition(position) {
            if (!availableJoinPositions.includes(position)) {
                announceToScreenReader(`${positionName(position)} not available`);
                return;
            }
            
            selectedJoinPosition = position;
            myPosition = position;
            
            socket.emit('selectPosition', {
                tableCode: tableCode,
                position: position,
                playerName: myName
            });
        }

        function cancelJoin() {
            showJoinTable();
            resetJoinTableUI();
        }

        // WAITING ROOM
        function updateWaitingRoomPositions(table) {
            const positions = ['north', 'east', 'south', 'west'];
            let playerCount = 0;
            
            for (const position of positions) {
                const element = document.getElementById(`waiting-position-${position}`);
                const player = table.players[position];
                const nameElement = element.querySelector('.player-name');
                
                if (player) {
                    playerCount++;
                    element.classList.add('occupied');
                    
                    if (player.id === socket.id || position === myPosition) {
                        element.classList.add('you');
                        nameElement.textContent = `${player.name} (You)`;
                    } else {
                        element.classList.remove('you');
                        nameElement.textContent = player.name;
                    }
                } else {
                    element.classList.remove('occupied', 'you');
                    nameElement.textContent = 'Waiting...';
                }
            }
            
            document.getElementById('waiting-player-count').textContent = playerCount;
            updateStatus();
            
            const startButton = document.getElementById('start-game-button');
            startButton.disabled = playerCount !== 4;
            startButton.textContent = playerCount === 4 ? 'Start Game' : `Start (${playerCount}/4)`;
            
            if (playerCount === 4) {
                announceToScreenReader('All players joined. Ready to start.');
            }
        }

        function copyTableCode() {
            const code = document.getElementById('share-table-code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                announceToScreenReader(`Code ${code} copied`);
                
                const button = document.getElementById('copy-code-button');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.disabled = true;
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            }).catch(() => {
                announceToScreenReader('Copy failed');
            });
        }

        function startGameFromWaiting() {
            if (!tableCode) {
                showErrorWithAnnouncement('No table code');
                return;
            }
            
            socket.emit('startGame', { tableCode: tableCode });
            announceToScreenReader('Starting game...');
        }

        function leaveTableFromWaiting() {
            if (confirm('Leave table?')) {
                socket.emit('leaveTable');
                showStartMenu();
                resetState();
            }
        }

        function sendWaitingChatMessage() {
            const input = document.getElementById('waiting-chat-input');
            const message = input.value.trim();
            if (!message) return;
            
            socket.emit('sendChatMessage', {
                tableCode: tableCode,
                message: message
            });
            
            input.value = '';
        }

        function addWaitingChatMessage(sender, position, message) {
            const chatArea = document.getElementById('waiting-chat-messages');
            if (!chatArea) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message';
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageElement.innerHTML = `
                <span>${sender} (${positionName(position)}): [${timestamp}]</span>
                <div>${message}</div>
            `;
            
            chatArea.appendChild(messageElement);
            chatArea.scrollTop = chatArea.scrollHeight;
            
            const now = Date.now();
            if (now - lastAnnouncementTime > 3000) {
                announceToScreenReader(`${sender}: ${message}`);
                lastAnnouncementTime = now;
            }
        }

        function addWaitingSystemMessage(message) {
            const chatArea = document.getElementById('waiting-chat-messages');
            if (!chatArea) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message system-message';
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageElement.innerHTML = `
                <span>[${timestamp}]</span>
                <div>${message}</div>
            `;
            
            chatArea.appendChild(messageElement);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // GAME FUNCTIONALITY
        function canViewHandCards(position) {
            if (position === myPosition) return true;
            
            if (gameState && 
                gameState.gamePhase === 'play' && 
                gameState.dummy === position) {
                return true;
            }
            
            return false;
        }

        function canPlayFromPosition(position) {
            if (!gameState || gameState.gamePhase !== 'play') return false;
            
            if (position === myPosition) return true;
            
            if (position === gameState.dummy && gameState.declarer === myPosition) {
                return true;
            }
            
            return false;
        }

function attemptToPlayCard(suit, card, fromPosition) {
    if (!tableCode || !gameState || gameState.gamePhase !== 'play') {
        showErrorWithAnnouncement('Cannot play card now');
        return;
    }
    
    const actualPosition = fromPosition || myPosition;
    const currentPlayer = gameState.currentPlayer;
    
    let isValidTurn = false;
    
    if (currentPlayer === myPosition && actualPosition === myPosition) {
        isValidTurn = true;
    } else if (currentPlayer === gameState.dummy && actualPosition === gameState.dummy) {
        if (gameState.declarer === myPosition) {
            isValidTurn = true;
        }
    }
    
    if (!isValidTurn) {
        showErrorWithAnnouncement(`It's ${positionName(currentPlayer)}'s turn`);
        return;
    }
    
    const hand = gameState.hands[actualPosition];
    if (!hand || !hand[suit] || !hand[suit].includes(card)) {
        showErrorWithAnnouncement(`You don't have ${getSuitName(suit)} ${card}`);
        return;
    }
    
    // Jos tikki on täysi (4 korttia), tyhjennä se - uusi tikki alkaa
    if (gameState.currentTrick && gameState.currentTrick.length === 4) {
        gameState.currentTrick = [];
    }
    
    // Tarkista maa-vaatimus
    // LISÄTTY: Tarkistus, että tikki ei ole täysi (length < 4), jotta uuden tikin aloitus onnistuu
    if (gameState.currentTrick && gameState.currentTrick.length > 0 && gameState.currentTrick.length < 4) {
        const leadSuit = gameState.currentTrick[0].suit;
        if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
            showErrorWithAnnouncement(`Must follow suit: ${getSuitName(leadSuit)}`);
            return;
        }
    }
    
    socket.emit('playCard', {
        tableCode: tableCode,
        position: actualPosition,
        suit: suit,
        card: card
    });
}

        /**
         * Determine all four position placements based on current player position
         * Returns { top: 'position', left: 'position', right: 'position', bottom: 'position' }
         */
        function getPositionLayout() {
            const layouts = {
                'south': {
                    top: 'north',
                    left: 'east',
                    right: 'west',
                    bottom: 'south'
                },
                'west': {
                    top: 'east',
                    left: 'south',
                    right: 'north',
                    bottom: 'west'
                },
                'north': {
                    top: 'south',
                    left: 'west',
                    right: 'east',
                    bottom: 'north'
                },
                'east': {
                    top: 'west',
                    left: 'north',
                    right: 'south',
                    bottom: 'east'
                }
            };
            
            return layouts[myPosition] || layouts['south'];
        }

        function renderHand(position, hand, targetElement) {
            if (!hand || !targetElement) return;
            
            let positionType = position === myPosition ? 'You' : 'Human';
            if (position === gameState?.dummy && gameState?.declarer === myPosition) {
                positionType = 'Dummy (You control)';
            }
            
            const canPlayFromThisPosition = canPlayFromPosition(position);
            const isPlayPhase = gameState && gameState.gamePhase === 'play';
            
            // Player name header
            let html = `<div class="hand-header">${positionName(position)} ${position === myPosition ? '' : `(${positionType})`}</div>`;
            
            // All cards in one row
            html += `<div class="all-cards-row">`;
            
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitNames = { spades: 'Spades', hearts: 'Hearts', diamonds: 'Diamonds', clubs: 'Clubs' };
            
            for (const suit of suits) {
                const cards = hand[suit] || [];
                const suitSymbol = getSuitSymbol(suit);
                const suitClass = `suit-${suit}`;
                
                if (cards.length > 0) {
                    cards.forEach(card => {
                        const cardLabel = `${suitNames[suit]} ${card}`;
                        
if (isPlayPhase && canPlayFromThisPosition) {
    html += `
        <button 
            class="card-button ${suitClass}"
            onclick="attemptToPlayCard('${suit}', '${card}', '${position}')"
            aria-label="${cardLabel}"
        >
            <span class="card-suit">${suitSymbol}</span>
            <span class="card-rank">${card}</span>
        </button>
    `;
} else {
    html += `
        <span class="card-display ${suitClass}" aria-label="${cardLabel}">
            <span class="card-suit">${suitSymbol}</span>
            <span class="card-rank">${card}</span>
        </span>
    `;
}
                    });
                }
            }
            
            html += `</div>`;
            targetElement.innerHTML = html;
            
            // Mark element states
            if (position === gameState?.dummy) {
                targetElement.classList.add('is-dummy');
            } else {
                targetElement.classList.remove('is-dummy');
            }
            
            if (position === gameState?.currentPlayer) {
                targetElement.classList.add('is-current-player');
            } else {
                targetElement.classList.remove('is-current-player');
            }
            
            targetElement.classList.add('has-cards');
        }

        function renderAllHands() {
            if (!gameState || !gameState.hands) return;
            
            const layout = getPositionLayout();
            
            // Render each position
            renderPositionArea('top', layout.top);
            renderPositionArea('left', layout.left);
            renderPositionArea('right', layout.right);
            renderPositionArea('bottom', layout.bottom);
        }

        function renderPositionArea(area, position) {
            const element = document.getElementById(`${area}-position-area`);
            if (!element) return;
            
            // Check if we can view this position's cards
            const canView = canViewHandCards(position);
            const hand = gameState.hands[position];
            
            if (canView && hand) {
                // Show full hand with cards
                renderHand(position, hand, element);
            } else {
                // Show only player name
                renderPlayerNameOnly(element, position);
            }
        }

        function renderPlayerNameOnly(element, position) {
            const playerName = gameState?.players?.[position]?.name || positionName(position);
            
            element.innerHTML = `<div class="position-name">${playerName}</div>`;
            element.classList.remove('has-cards', 'is-dummy');
            
            if (position === gameState?.currentPlayer) {
                element.classList.add('is-current-player');
            } else {
                element.classList.remove('is-current-player');
            }
        }

        function updateCurrentTrickDisplay() {
            const container = document.getElementById('game-played-cards-container');
            if (!container) return;
            
            if (!gameState || !gameState.currentTrick || gameState.currentTrick.length === 0) {
                container.innerHTML = '<p>No cards played yet</p>';
                return;
            }
            
            let html = '<div class="current-trick-cards">';
            
            for (const card of gameState.currentTrick) {
                const suitClass = `suit-${card.suit}`;
                html += `
                    <div class="played-card">
                        <div class="player-label">${positionName(card.player)}</div>
<div class="card ${suitClass}">
    <span class="card-suit">${getSuitSymbol(card.suit)}</span>
    <span class="card-rank">${card.card}</span>
</div>
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function updateGameUI() {
            if (!gameState) return;
            
            // Update scores
            updateScoreDisplay();
            
            // Update contract info
            updateContractDisplay();
            
            // Update current trick
            updateCurrentTrickDisplay();
            
            updateStatus();
        }

        function updateScoreDisplay() {
            if (gameState && gameState.tricks) {
                document.getElementById('ns-score').textContent = `NS ${gameState.tricks.ns}/13`;
                document.getElementById('ew-score').textContent = `EW ${gameState.tricks.ew}/13`;
            } else {
                document.getElementById('ns-score').textContent = 'NS 0/13';
                document.getElementById('ew-score').textContent = 'EW 0/13';
            }
        }

        function updateContractDisplay() {
            const contractInfo = document.getElementById('contract-info');
            
            if (gameState && gameState.contract && gameState.declarer) {
                document.getElementById('contract-display').textContent = formatContract(gameState.contract);
                document.getElementById('declarer-info').textContent = `by ${positionName(gameState.declarer)}`;
                contractInfo.style.display = 'block';
            } else {
                contractInfo.style.display = 'none';
            }
        }

        function renderBiddingUI() {
            const biddingArea = document.getElementById('game-bidding-area');
            if (biddingArea) {
                biddingArea.style.display = 'block';
            }
            
            renderBiddingHistory();
            
            if (biddingState && biddingState.currentBidder === myPosition) {
                renderBiddingControls();
            } else {
                const biddingControls = document.getElementById('game-bidding-controls');
                if (biddingControls) {
                    biddingControls.innerHTML = `
                        <h3>Your Bid</h3>
                        <p>Waiting for ${positionName(biddingState ? biddingState.currentBidder : 'unknown')}</p>
                    `;
                }
            }
        }

        function renderBiddingHistory() {
            const biddingHistory = document.getElementById('game-bidding-history');
            if (!biddingHistory) return;
            
            let html = '<h3>History</h3>';
            
            if (!biddingState || !biddingState.bidHistory || biddingState.bidHistory.length === 0) {
                html += '<p>No bids yet</p>';
            } else {
                html += '<table><tr><th>W</th><th>N</th><th>E</th><th>S</th></tr>';
                
                const positions = ['west', 'north', 'east', 'south']; // Bidding order starts at dealer
                let dealerPosition = biddingState.dealer || 'south';
                
                // Find start index based on dealer
                let dealerIndex = positions.indexOf(dealerPosition);
                
                // Adjust position order so that dealer is at the start of the list
                const adjustedPositions = positions.slice(dealerIndex).concat(positions.slice(0, dealerIndex));
                
                // Fix header row (should be in fixed order N E S W)
                html += '<table><tr><th>W</th><th>N</th><th>E</th><th>S</th></tr>';
                
                const rounds = [];
                let currentRound = [];
                let currentPosIndex = positions.indexOf(biddingState.dealer || 'south');
                
                for (const bid of biddingState.bidHistory) {
                    // Fill nulls until current position is reached (only at start of round)
                    if (currentRound.length === 0) {
                        const roundStartPosIndex = currentPosIndex;
                        const startOfTableIndex = positions.indexOf('west');
                        
                        let offset = (roundStartPosIndex - startOfTableIndex + 4) % 4;
                        
                        for (let i = 0; i < offset; i++) {
                             // This part is tricky due to the fixed table header (W N E S) vs. variable start pos
                             // Simpler: iterate 4 positions and put bid in the right column
                             // Let's rely on server state's bidHistory having correct order, 
                             // and render based on fixed WNES columns.
                             // This simplified rendering logic is error-prone based on dealer, I'll use the existing logic from the original file for rendering.
                        }
                    }
                    
                    currentRound.push(bid);
                    
                    if (currentRound.length === 4) {
                        rounds.push([...currentRound]);
                        currentRound = [];
                    }
                }
                
                if (currentRound.length > 0) {
                    rounds.push([...currentRound]);
                }
                
                // Re-creating the original rendering logic for W N E S columns.
                
                const renderPositions = ['west', 'north', 'east', 'south'];
                let currentPositionIndex = renderPositions.indexOf(biddingState.dealer || 'south');
                let bidHistoryIndex = 0;

                html = '<h3>History</h3>';
                html += '<table><tr><th>W</th><th>N</th><th>E</th><th>S</th></tr>';

                while (bidHistoryIndex < biddingState.bidHistory.length) {
                    html += '<tr>';
                    
                    // Add empty cells for positions before the dealer's first bid
                    for (let i = 0; i < 4; i++) {
                        const colPosition = renderPositions[i];
                        
                        if (bidHistoryIndex >= biddingState.bidHistory.length) {
                            html += '<td></td>';
                        } else {
                            const bid = biddingState.bidHistory[bidHistoryIndex];
                            
                            // Check if this bid belongs to the current column (W, N, E, S)
                            if (bid.player === colPosition) {
                                html += `<td>${formatBid(bid.bid)}</td>`;
                                bidHistoryIndex++;
                                
                                // Reset position index to start of round if needed
                                if (bidHistoryIndex % 4 === 0) {
                                    currentPositionIndex = 0;
                                } else {
                                    currentPositionIndex = (currentPositionIndex + 1) % 4;
                                }
                            } else {
                                html += '<td></td>';
                            }
                        }
                    }
                    
                    html += '</tr>';
                }
                
                html += '</table>';
            }
            
            biddingHistory.innerHTML = html;
            
            // Re-implementing simplified rendering logic based on the original file's structure.
            // The table structure in the original file is based on W N E S columns.
            // I'll adjust the rendering to fit the WNES columns properly based on dealer start.
            
            if (biddingState && biddingState.bidHistory && biddingState.bidHistory.length > 0) {
                const bids = biddingState.bidHistory;
                const dealer = biddingState.dealer || 'south';
                const positions = ['west', 'north', 'east', 'south'];
                const dealerIndex = positions.indexOf(dealer);
                
                let bidsInTable = [];
                let tempRow = Array(4).fill(null);
                let currentCellIndex = (dealerIndex + 1) % 4; // Start index in the W N E S table columns
                
                // Fill empty cells for positions before the dealer's first bid in the WNES table
                for (let i = 0; i < dealerIndex; i++) {
                    tempRow[i] = { bid: '' }; // Empty cell
                }
                
                let bidIndex = 0;
                let currentBidderPosition = dealer;

                // Adjusting the starting position in the W N E S columns
                let tableStartIndex = positions.indexOf(currentBidderPosition);
                
                for (let i = 0; i < bids.length; i++) {
                    const bid = bids[i];
                    const posIndex = positions.indexOf(bid.player); // W=0, N=1, E=2, S=3
                    
                    tempRow[posIndex] = bid;
                    
                    // If the current cell index is the last in the row, or the last bid
                    if (posIndex === 3 || i === bids.length - 1) {
                         // Check if we can complete a row (S is the last column)
                        let isRowComplete = true;
                        for (let k = 0; k < 4; k++) {
                            if (!tempRow[k]) isRowComplete = false;
                        }
                        
                        if (isRowComplete) {
                            bidsInTable.push(tempRow);
                            tempRow = Array(4).fill(null);
                        }
                    }
                    
                    // Simple logic for continuous bidding in W N E S columns:
                    if (posIndex === 3) {
                         bidsInTable.push([...tempRow]);
                         tempRow = Array(4).fill(null);
                    } else if (i === bids.length - 1) {
                         bidsInTable.push([...tempRow]);
                    }
                }
                
                // Simple implementation that respects W N E S columns and dealer start
                
                html = '<h3>History</h3><table><tr><th>W</th><th>N</th><th>E</th><th>S</th></tr>';

                let bidCount = 0;
                let rows = [];
                let currentRow = Array(4).fill(null);
                
                // Find index of dealer in W N E S order
                let dealerPosIndex = positions.indexOf(dealer);
                
                // Initialize the first row with empty cells up to the dealer
                for (let i = 0; i < dealerPosIndex; i++) {
                    currentRow[i] = { bid: '' };
                }
                
                for (const bid of bids) {
                    const posIndex = positions.indexOf(bid.player);
                    
                    // If the bid's position is not the expected one in the current row, 
                    // it means we finished a round in the previous iteration and need a new row.
                    
                    // Find the first empty spot *after* the previous bid or *after* dealer for first round
                    let nextEmptySpot = -1;
                    for (let i = 0; i < 4; i++) {
                        if (currentRow[i] === null) {
                            nextEmptySpot = i;
                            break;
                        }
                    }

                    if (nextEmptySpot === -1) {
                         // Row is full, start new row
                         rows.push(currentRow);
                         currentRow = Array(4).fill(null);
                         nextEmptySpot = 0;
                    }
                    
                    // Place the bid in the correct column
                    currentRow[posIndex] = bid;
                    
                    // If we've hit the end of the row, push it.
                    if (posIndex === 3) {
                         rows.push(currentRow);
                         currentRow = Array(4).fill(null);
                    }
                }

                if (currentRow.some(c => c !== null)) {
                    rows.push(currentRow);
                }
                
                for (const row of rows) {
                    html += '<tr>';
                    for (const cell of row) {
                        html += `<td>${cell ? formatBid(cell.bid) : ''}</td>`;
                    }
                    html += '</tr>';
                }

                html += '</table>';
                
            }
            
            biddingHistory.innerHTML = html;
        }


        function renderBiddingControls() {
            const biddingControls = document.getElementById('game-bidding-controls');
            if (!biddingControls) return;
            
            const possibleBids = getPossibleBids(biddingState ? biddingState.highestBid : null);
            
            let html = '<h3>Your Bid</h3><div class="bidding-buttons">';
            
            for (const specialBid of ['P', 'X', 'XX']) {
                if (possibleBids.includes(specialBid)) {
                    const bidText = specialBid === 'P' ? 'Pass' : 
                                  specialBid === 'X' ? 'Double' : 'Redouble';
                    
                    html += `<button onclick="makeBid('${specialBid}')">${bidText}</button>`;
                }
            }
            
            const contractBids = possibleBids.filter(bid => !['P', 'X', 'XX'].includes(bid));
            const bidsByLevel = {};
            
            for (const bid of contractBids) {
                const level = bid.charAt(0);
                if (!bidsByLevel[level]) bidsByLevel[level] = [];
                bidsByLevel[level].push(bid);
            }
            
            for (const level in bidsByLevel) {
                html += `<div class="bid-level-group">`;
                
                for (const bid of bidsByLevel[level]) {
                    const suit = bid.charAt(1);
                    let suitSymbol, suitClass;
                    
                    switch(suit) {
                        case 'C': suitSymbol = '♣'; suitClass = 'bid-clubs'; break;
                        case 'D': suitSymbol = '♦'; suitClass = 'bid-diamonds'; break;
                        case 'H': suitSymbol = '♥'; suitClass = 'bid-hearts'; break;
                        case 'S': suitSymbol = '♠'; suitClass = 'bid-spades'; break;
                        case 'N': suitSymbol = 'NT'; suitClass = 'bid-notrump'; break;
                        default: suitSymbol = suit; suitClass = '';
                    }
                    
                    html += `<button class="${suitClass}" onclick="makeBid('${bid}')">${level}${suitSymbol}</button>`;
                }
                
                html += `</div>`;
            }
            
            html += '</div>';
            biddingControls.innerHTML = html;
        }

        function makeBid(bid) {
            if (!tableCode) return;
            
            socket.emit('makeBid', {
                tableCode: tableCode,
                position: myPosition,
                bid: bid
            });
        }

        function getPossibleBids(highestBid) {
            const possibleBids = ['P'];
            
            if (highestBid && !highestBid.includes('X')) {
                possibleBids.push('X');
            }
            if (highestBid && highestBid.includes('X') && !highestBid.includes('XX')) {
                possibleBids.push('XX');
            }
            
            const levels = ['1', '2', '3', '4', '5', '6', '7'];
            const suits = ['C', 'D', 'H', 'S', 'N'];
            
            if (!highestBid || highestBid === 'P' || highestBid === 'X' || highestBid === 'XX') {
                for (const level of levels) {
                    for (const suit of suits) {
                        possibleBids.push(`${level}${suit}`);
                    }
                }
            } else {
                const highestLevel = parseInt(highestBid.charAt(0));
                const highestSuit = highestBid.charAt(1);
                const highestSuitIndex = suits.indexOf(highestSuit);
                
                for (let level = highestLevel; level <= 7; level++) {
                    for (let suitIndex = 0; suitIndex < suits.length; suitIndex++) {
                        if (level === highestLevel && suitIndex <= highestSuitIndex) continue;
                        possibleBids.push(`${level}${suits[suitIndex]}`);
                    }
                }
            }
            
            return possibleBids;
        }

        function sendGameChatMessage() {
            const input = document.getElementById('game-chat-input');
            const message = input.value.trim();
            if (!message) return;
            
            socket.emit('sendChatMessage', {
                tableCode: tableCode,
                message: message
            });
            
            input.value = '';
        }

        function startNewGameFromGame() {
            if (confirm('Start new game?')) {
                socket.emit('startNewGame', {
                    tableCode: tableCode
                });
            }
        }

        function leaveGameFromGame() {
            if (confirm('Leave game?')) {
                socket.emit('leaveTable');
                showStartMenu();
                resetState();
            }
        }

        // UTILITY FUNCTIONS
        function positionName(position) {
            const names = { north: 'North', east: 'East', south: 'South', west: 'West' };
            return names[position] || position || 'Unknown';
        }

        function getSuitName(suit) {
            const names = { spades: 'Spades', hearts: 'Hearts', diamonds: 'Diamonds', clubs: 'Clubs' };
            return names[suit] || suit;
        }

        function getSuitSymbol(suit) {
            const symbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
            return symbols[suit] || suit;
        }

        function formatContract(contract) {
            if (!contract) return "No contract";
            
            const level = contract.charAt(0);
            const suit = contract.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            let result = `${level}${suitSymbol}`;
            
            if (contract.includes('XX')) {
                result += ' XX';
            } else if (contract.includes('X')) {
                result += ' X';
            }
            
            return result;
        }

        function formatBid(bid) {
            if (bid === 'P') return 'Pass';
            if (bid === 'X') return 'X';
            if (bid === 'XX') return 'XX';
            
            const level = bid.charAt(0);
            const suit = bid.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            return `${level}${suitSymbol}`;
        }

        function resetState() {
            tableCode = null;
            gameState = null;
            biddingState = null;
            myPosition = null;
            myName = null;
            selectedCreatePosition = 'south';
            selectedJoinPosition = null;
            availableJoinPositions = [];
            
            const inputs = ['create-name-input', 'table-name-input', 'join-name-input', 'table-code-input'];
            inputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = '';
            });
            
            resetCreateTableUI();
            resetJoinTableUI();
        }

        function showError(message, duration = 5000) {
            console.error('Error:', message);
            
            let errorArea = document.getElementById('error-area');
            if (!errorArea) {
                errorArea = document.createElement('div');
                errorArea.id = 'error-area';
                errorArea.className = 'error-message';
                errorArea.style.cssText = 'padding: 10px; margin: 10px 0; background: #ffebee; color: #c62828; border: 1px solid #ef5350; border-radius: 4px;';
                
                const container = document.querySelector('.container') || document.body;
                container.insertBefore(errorArea, container.firstChild);
            }
            
            errorArea.textContent = message;
            errorArea.style.display = 'block';
            
            setTimeout(() => {
                if (errorArea) {
                    errorArea.style.display = 'none';
                }
            }, duration);
        }

        // HELP AND UI FUNCTIONS
        function updateHelpContent() {
            const helpList = document.getElementById('help-list');
            helpList.innerHTML = '';
            
            // Complete list of all keyboard shortcuts organized by category
            const allShortcuts = [
                { key: '', desc: '--- Global Commands (Available Everywhere) ---' },
                { key: 'Alt + H', desc: 'Toggle this help dialog' },
                { key: 'Alt + I', desc: 'Repeat last screen reader announcement' },
                { key: 'Alt + B', desc: 'Back/Cancel (context-dependent)' },
                { key: 'Escape', desc: 'Close help dialog' },
                { key: 'Tab', desc: 'Navigate between elements' },
                { key: 'Enter/Space', desc: 'Activate buttons and links' },
                
                { key: '', desc: '--- Main Menu ---' },
                { key: 'Arrow keys', desc: 'Navigate between Create/Join buttons' },
                
                { key: '', desc: '--- Create Table ---' },
                { key: 'Alt + C', desc: 'Create table (if form is valid)' },
                { key: 'Enter', desc: 'Move to next field or submit form' },
                { key: 'Arrow keys', desc: 'Navigate position selection (North/East/South/West)' },
                
                { key: '', desc: '--- Join Table ---' },
                { key: 'Alt + J', desc: 'Join table (if form is valid)' },
                { key: 'Enter', desc: 'Move to next field or submit form' },
                
                { key: '', desc: '--- Position Selection ---' },
                { key: 'Arrow keys', desc: 'Navigate available positions' },
                { key: 'Enter/Space', desc: 'Select position' },
                
                { key: '', desc: '--- Waiting Room ---' },
                { key: 'Alt + S', desc: 'Start game (when 4 players present)' },
                { key: 'Alt + L', desc: 'Leave table' },
                { key: 'Alt + C', desc: 'Focus on chat input' },
                { key: 'Enter', desc: 'Send chat message (when in chat input)' },
                
                { key: '', desc: '--- Game: Basic Controls ---' },
                { key: 'Alt + M', desc: 'Leave game' },
                { key: 'Enter', desc: 'Send chat message (when in chat input)' },
                { key: 'Tab/Arrow keys', desc: 'Navigate between game elements' },
                
                { key: '', desc: '--- Game: Bidding Phase ---' },
                { key: 'Alt + P', desc: 'Pass bid (when it\'s your turn)' },
                { key: '1-7', desc: 'Select bid level (then press suit key)' },
                { key: 'S', desc: 'Spades suit (after selecting level)' },
                { key: 'H', desc: 'Hearts suit (after selecting level)' },
                { key: 'D', desc: 'Diamonds suit (after selecting level)' },
                { key: 'C', desc: 'Clubs suit (after selecting level)' },
                { key: 'N', desc: 'No Trump (after selecting level)' },
                
                { key: '', desc: '--- Game: Card Viewing (Your Hand) ---' },
                { key: 'Alt + A', desc: 'Announce your spades and focus lowest card' },
                { key: 'Alt + S', desc: 'Announce your hearts and focus lowest card' },
                { key: 'Alt + D', desc: 'Announce your diamonds and focus lowest card' },
                { key: 'Alt + F', desc: 'Announce your clubs and focus lowest card' },
                { key: 'Alt + G', desc: 'Announce your entire hand (all suits)' },
                
                { key: '', desc: '--- Game: Card Viewing (Dummy Hand) ---' },
                { key: 'Alt + Q', desc: 'Announce dummy spades and focus lowest card' },
                { key: 'Alt + W', desc: 'Announce dummy hearts and focus lowest card' },
                { key: 'Alt + E', desc: 'Announce dummy diamonds and focus lowest card' },
                { key: 'Alt + R', desc: 'Announce dummy clubs and focus lowest card' },
                { key: 'Alt + T', desc: 'Announce dummy entire hand (all suits)' },
                
                { key: '', desc: '--- Game: Information Commands ---' },
                { key: 'Alt + C', desc: 'Announce cards in current trick/bidding history' },
                { key: 'Alt + X', desc: 'Announce game state and contract' },
                { key: 'Alt + V', desc: 'Announce current player' },
                { key: 'Alt + O', desc: 'Announce current score (tricks won)' },
                
                { key: '', desc: '--- Game: Quick Card Play (Highest) ---' },
                { key: 'Ctrl + 1', desc: 'Play highest spade' },
                { key: 'Ctrl + 2', desc: 'Play highest heart' },
                { key: 'Ctrl + 3', desc: 'Play highest diamond' },
                { key: 'Ctrl + 4', desc: 'Play highest club' },
                
                { key: '', desc: '--- Game: Quick Card Play (Lowest) ---' },
                { key: 'Alt + 1', desc: 'Play lowest spade' },
                { key: 'Alt + 2', desc: 'Play lowest heart' },
                { key: 'Alt + 3', desc: 'Play lowest diamond' },
                { key: 'Alt + 4', desc: 'Play lowest club' },
                
                { key: '', desc: '--- Game: Manual Card Play ---' },
                { key: 'Click/Enter', desc: 'Play specific card (navigate to card first)' },
                { key: 'Tab/Arrow keys', desc: 'Navigate between playable cards' },
                
                { key: '', desc: '--- Notes ---' },
                { key: '', desc: 'Card viewing commands work only when cards are visible' },
                { key: '', desc: 'Quick play commands work only during your turn' },
                { key: '', desc: 'Bidding commands work only during bidding phase' },
                { key: '', desc: 'Some commands are context-dependent' }
            ];
            
            allShortcuts.forEach(shortcut => {
                const li = document.createElement('li');
                if (shortcut.key === '') {
                    // Section header or note
                    if (shortcut.desc.startsWith('---')) {
                        li.innerHTML = `<strong style="color: #2c5aa0; font-size: 1.1em; margin-top: 15px; display: block;">${shortcut.desc}</strong>`;
                    } else {
                        li.innerHTML = `<em style="color: #666; font-style: italic;">${shortcut.desc}</em>`;
                    }
                    li.style.marginTop = '8px';
                    li.style.marginBottom = '5px';
                } else {
                    li.innerHTML = `<strong style="color: #0066cc; font-family: monospace;">${shortcut.key}</strong>: ${shortcut.desc}`;
                    li.style.marginBottom = '2px';
                    li.style.paddingLeft = '10px';
                }
                helpList.appendChild(li);
            });
        }

        function toggleHelp() {
            uiState.showHelp = !uiState.showHelp;
            document.getElementById('help-section').style.display = uiState.showHelp ? 'block' : 'none';
            document.getElementById('toggle-help-button').textContent = uiState.showHelp ? 'Hide Help' : 'Help';
            document.getElementById('toggle-help-button').setAttribute('aria-expanded', uiState.showHelp);
            
            if (uiState.showHelp) {
                updateHelpContent();
                // Focus on help title for better screen reader experience
                setTimeout(() => document.getElementById('help-title').focus(), 100);
            }
        }

        function closeHelp() {
            uiState.showHelp = false;
            document.getElementById('help-section').style.display = 'none';
            document.getElementById('toggle-help-button').textContent = 'Help';
            document.getElementById('toggle-help-button').setAttribute('aria-expanded', 'false');
            document.getElementById('toggle-help-button').focus();
        }

        function navigate(page) {
            window.location.href = page;
        }

        function repeatLastAnnouncement() {
            if (uiState.lastAnnouncement) {
                announcementQueue.repeatLast();
            } else {
                announceToScreenReader("No announcement to repeat.");
            }
        }

        function updateDealInfo() {
            document.getElementById('deal-number').textContent = dealNumber;
            document.getElementById('current-dealer').textContent = positionName(currentDealer);
            document.getElementById('deal-info-area').style.display = 'block';
        }

        // AUDIO FUNCTIONS
        function toistaAani(aaniTyyppi) {
            if (aanetAlustettu && sounds[aaniTyyppi]) {
                sounds[aaniTyyppi].play();
            }
        }

        async function alustaAanet() {
            try {
                sounds.deal.volume(0.1);
                await new Promise((resolve) => {
                    sounds.deal.once('play', resolve);
                    sounds.deal.play();
                });
                sounds.deal.stop();
                sounds.deal.volume(0.5);

                aanetAlustettu = true;
                document.getElementById('aaniStatus').textContent = 'Enabled';
            } catch (error) {
                console.warn('Audio error:', error);
                document.getElementById('aaniStatus').textContent = 'Failed';
            }
        }

        function muutaAaniAsetukset() {
            const checkbox = document.getElementById('aanetKaytossa');
            const statusTeksti = document.getElementById('aaniStatus');
            
            if (checkbox.checked) {
                if (!aanetAlustettu) {
                    alustaAanet();
                } else {
                    statusTeksti.textContent = 'Enabled';
                }
            } else {
                aanetAlustettu = false;
                statusTeksti.textContent = 'Disabled';
            }
        }

        function muutaSyntetisaattoriAsetukset() {
            const checkbox = document.getElementById('useSynthesizer');
            const statusTeksti = document.getElementById('synthStatus');
            
            useSynthesizerEnabled = checkbox.checked;
            statusTeksti.textContent = useSynthesizerEnabled ? 'Enabled' : 'Disabled';
            
            // Save setting to localStorage
            localStorage.setItem('useSynthesizer', useSynthesizerEnabled.toString());
            
            // Announce the change
            if (useSynthesizerEnabled) {
                speakMessage('Synthesizer enabled');
            }
        }

/**
 * Returns suit name in singular or plural form
 */
function getSuitNameWithCount(suit, count) {
    const singular = { spades: 'Spade', hearts: 'Heart', diamonds: 'Diamond', clubs: 'Club' };
    const plural = { spades: 'Spades', hearts: 'Hearts', diamonds: 'Diamonds', clubs: 'Clubs' };
    
    return count === 1 ? singular[suit] : plural[suit];
}

        
        /**
         * Announces cards in a specific suit from a hand AND focuses on lowest card
         */
        function announceHandSuitWithFocus(position, suit) {
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                const message = `Cannot view ${positionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${positionName(position)}.`);
                return;
            }
            
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
const message = `No ${getSuitName(suit)}s.`;
                announceToScreenReader(message);
                return;
            }
            
const message = `${cards.length} ${getSuitNameWithCount(suit, cards.length)}: ${cards.join(', ')}`;
            announceToScreenReader(message);
            
            // Focus on lowest card
            focusOnLowestCard(position, suit);
        }

/**
 * Announces all cards in a hand
 */
function announceEntireHand(position) {
    const canViewCards = canViewHandCards(position);
    
    if (!canViewCards) {
        const message = `Cannot view ${positionName(position)}'s cards at this time.`;
        announceToScreenReader(message);
        return;
    }
    
    const hand = gameState && gameState.hands ? gameState.hands[position] : null;
    if (!hand) {
        announceToScreenReader(`No cards available for ${positionName(position)}.`);
        return;
    }
    
    let message = `Your hand: `;
    const suitMessages = [];
    
    for (const suit of ['spades', 'hearts', 'diamonds', 'clubs']) {
        const cards = hand[suit] || [];
        const count = cards.length;
        const suitName = getSuitNameWithCount(suit, count);
        
        if (count > 0) {
            suitMessages.push(`${count} ${suitName}: ${cards.join(', ')}`);
        } else {
            suitMessages.push(`0 ${suitName}`);
        }
    }
    
    message += suitMessages.join('. ') + '.';
    announceToScreenReader(message);
}

/**
 * Announces the bidding history
 */
function announceBiddingHistory() {
    if (!biddingState || !biddingState.bidHistory || biddingState.bidHistory.length === 0) {
        announceToScreenReader('No bids yet.');
        return;
    }
    
    const positions = ['west', 'north', 'east', 'south'];
    const dealerIndex = positions.indexOf(biddingState.dealer || 'south');
    
    let parts = [];
    let currentPosition = dealerIndex;
    
    for (const bidObj of biddingState.bidHistory) {
        const position = positions[currentPosition % 4];
        const posName = positionName(position);
        
        let bidText;
        if (bidObj.bid === 'P') {
            bidText = 'passes';
        } else if (bidObj.bid === 'X') {
            bidText = 'doubles';
        } else if (bidObj.bid === 'XX') {
            bidText = 'redoubles';
        } else {
            bidText = formatBid(bidObj.bid);
        }
        
        parts.push(`${posName} ${bidText}`);
        
        currentPosition = (currentPosition + 1) % 4;
    }
    
    const message = parts.join(', ') + '.';
    announceToScreenReader(message);
}

        function announceCurrentTrick() {
            try {
                if (!gameState || !gameState.currentTrick || !Array.isArray(gameState.currentTrick) || gameState.currentTrick.length === 0) {
                    announceToScreenReader('No cards played yet.');
                    return;
                }
                
                let parts = [];
                for (const card of gameState.currentTrick) {
                    let who = positionName(card.player);
                    let suitName = getSuitName(card.suit);
                    parts.push(`${who} ${suitName} ${card.card}`.trim());
                }
                const message = parts.join(', ');
                announceToScreenReader(message);
            } catch (e) {
                console.error('announceCurrentTrick error:', e);
                announceToScreenReader('Error reading current trick.');
            }
        }

        function announceGameState() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            let message = `Game phase: ${gameState.gamePhase}. `;
            
            if (gameState.gamePhase === 'play' || gameState.gamePhase === 'end') {
                message += `Contract: ${formatContract(gameState.contract)} by ${positionName(gameState.declarer)}. `;
                message += `North-South tricks: ${gameState.tricks.ns}. East-West tricks: ${gameState.tricks.ew}. `;
                message += `Current player: ${positionName(gameState.currentPlayer)}.`;
                
                if (gameState.declarer === myPosition) {
                    message += ` You are the declarer and can control both your hand and dummy.`;
                }
            } else if (gameState.gamePhase === 'bidding') {
                message += `Current bidder: ${positionName(biddingState ? biddingState.currentBidder : 'unknown')}.`;
            }
                if (myPosition) {
        message += ` You are ${positionName(myPosition)}.`;
    }
            announceToScreenReader(message);
        }

        /**
         * Announces the current player
         */
        function announceCurrentPlayer() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            if (gameState.gamePhase === 'play') {
                let message = `Current player: ${positionName(gameState.currentPlayer)}.`;
                
                if (gameState.currentPlayer === gameState.dummy && gameState.declarer === myPosition) {
                    message += ` You control the dummy as the declarer.`;
                }
                
                announceToScreenReader(message);
            } else if (gameState.gamePhase === 'bidding') {
                announceToScreenReader(`Current bidder: ${positionName(biddingState ? biddingState.currentBidder : 'unknown')}.`);
            } else {
                announceToScreenReader(`Game phase: ${gameState.gamePhase}. No current player.`);
            }
        }

        /**
         * Announces the score
         */
        function announceScore() {
            if (gameState && (gameState.gamePhase === 'play' || gameState.gamePhase === 'end')) {
                announceToScreenReader(`North-South: ${gameState.tricks.ns} tricks. East-West: ${gameState.tricks.ew} tricks.`);
            } else {
                announceToScreenReader("No score available yet.");
            }
        }

        /**
         * Finds lowest card using bridge order
         */
        function findLowestCard(cards) {
            if (!cards || cards.length === 0) return null;
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => cardValues.indexOf(a) - cardValues.indexOf(b));
            return sortedCards[0];
        }

        /**
         * Finds highest card using bridge order
         */
        function findHighestCard(cards) {
            if (!cards || cards.length === 0) return null;
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => cardValues.indexOf(b) - cardValues.indexOf(a));
            return sortedCards[0];
        }

        /**
         * Focus on lowest card in suit
         */
        function focusOnLowestCard(position, suit) {
            if (!gameState || !gameState.hands || !gameState.hands[position]) return;
            
            const hand = gameState.hands[position];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) return;
            
            const lowestCard = findLowestCard(cards);
            if (!lowestCard) return;
            
            const layout = getPositionLayout();
            let areaId = 'bottom-position-area'; // Default to player
            
            // Find which area this position is in
            if (position === layout.top) areaId = 'top-position-area';
            else if (position === layout.left) areaId = 'left-position-area';
            else if (position === layout.right) areaId = 'right-position-area';
            else if (position === layout.bottom) areaId = 'bottom-position-area';
            
            const handArea = document.getElementById(areaId);
            
            if (!handArea) return;
            
            const cardButton = handArea.querySelector(`button[onclick*="attemptToPlayCard('${suit}', '${lowestCard}'"]`);
            
            if (cardButton) {
                setTimeout(() => {
                    cardButton.focus();
                }, 250);
            }
        }

        /**
         * Plays the highest card of a suit
         */
        function playHighestCard(suit) {
            const currentPlayer = gameState?.currentPlayer;
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader("Game is not in play phase.");
                return;
            }
            
            const canControl = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControl) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
// Tarkista maa-vaatimus vain jos tikki on käynnissä (1-3 korttia)
// Jos tikissä on 4 korttia, se on valmis ja uusi tikki alkaa
if (gameState.currentTrick && gameState.currentTrick.length > 0 && gameState.currentTrick.length < 4) {
    const leadSuit = gameState.currentTrick[0].suit;
    if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
        showErrorWithAnnouncement(`Must follow suit: ${getSuitName(leadSuit)}`);
        return;
    }
}
            
            const highestCard = findHighestCard(cards);
            
            if (highestCard) {
                attemptToPlayCard(suit, highestCard, currentPlayer);
            }
        }

        /**
         * Plays the lowest card of a suit
         */
        function playLowestCard(suit) {
            const currentPlayer = gameState?.currentPlayer;
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader("Game is not in play phase.");
                return;
            }
            
            const canControl = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControl) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
            // LISÄTTY: Tarkistus, että tikki ei ole täysi (length < 4), jotta uuden tikin aloitus onnistuu
            if (gameState.currentTrick && gameState.currentTrick.length > 0 && gameState.currentTrick.length < 4) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            const lowestCard = findLowestCard(cards);
            
            if (lowestCard) {
                attemptToPlayCard(suit, lowestCard, currentPlayer);
            }
        }

        /**
         * Check if it's our turn to play from a specific position
         */
        function isOurTurnToPlay(position) {
            if (!gameState || gameState.gamePhase !== 'play') return false;
            
            const currentPlayer = gameState.currentPlayer;
            
            if (position === myPosition && currentPlayer === myPosition) return true;
            
            if (position === gameState.dummy && currentPlayer === gameState.dummy && 
                gameState.declarer === myPosition) {
                return true;
            }
            
            return false;
        }

        // KEYBOARD SHORTCUTS
        function setupKeyboardListeners() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && uiState.showHelp) {
                    e.preventDefault();
                    closeHelp();
                    return;
                }

                // Process advanced keyboard shortcuts when in game
                if (currentView === 'game') {
                    // Card viewing shortcuts (Own cards)
                    if (e.altKey && e.key.toLowerCase() === 'a') {
                        e.preventDefault();
                        announceHandSuitWithFocus(myPosition, 'spades');
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 's') {
                        e.preventDefault();
                        announceHandSuitWithFocus(myPosition, 'hearts');
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'd') {
                        e.preventDefault();
                        announceHandSuitWithFocus(myPosition, 'diamonds');
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'f') {
                        e.preventDefault();
                        announceHandSuitWithFocus(myPosition, 'clubs');
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'g') {
                        e.preventDefault();
                        announceEntireHand(myPosition);
                        return;
                    }

                    // Card viewing shortcuts (Dummy's cards)
                    if (e.altKey && e.key.toLowerCase() === 'q') {
                        e.preventDefault();
                        if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                            announceHandSuitWithFocus(gameState.dummy, 'spades');
                        } else {
                            announceToScreenReader('Cannot view dummy spades at this time.');
                        }
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'w') {
                        e.preventDefault();
                        if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                            announceHandSuitWithFocus(gameState.dummy, 'hearts');
                        } else {
                            announceToScreenReader('Cannot view dummy hearts at this time.');
                        }
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'e') {
                        e.preventDefault();
                        if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                            announceHandSuitWithFocus(gameState.dummy, 'diamonds');
                        } else {
                            announceToScreenReader('Cannot view dummy diamonds at this time.');
                        }
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'r') {
                        e.preventDefault();
                        if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                            announceHandSuitWithFocus(gameState.dummy, 'clubs');
                        } else {
                            announceToScreenReader('Cannot view dummy clubs at this time.');
                        }
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 't') {
                        e.preventDefault();
                        if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
                            announceEntireHand(gameState.dummy);
                        } else {
                            announceToScreenReader('Cannot view all dummy cards at this time.');
                        }
                        return;
                    }

                    // Game state shortcuts
if (e.altKey && e.key.toLowerCase() === 'c') {
    e.preventDefault();
    // Tarjousvaiheessa: lue tarjoushistoria, pelivaiheessa: lue nykyinen tikki
    if (gameState && gameState.gamePhase === 'bidding') {
        announceBiddingHistory();
    } else {
        announceCurrentTrick();
    }
    return;
}
                    if (e.altKey && e.key.toLowerCase() === 'x') {
                        e.preventDefault();
                        announceGameState();
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'v') {
                        e.preventDefault();
                        announceCurrentPlayer();
                        return;
                    }
                    if (e.altKey && e.key.toLowerCase() === 'o') {
                        e.preventDefault();
                        announceScore();
                        return;
                    }

                    // Card playing shortcuts - high cards
                    if (e.ctrlKey && e.key === '1' && !e.altKey) {
                        e.preventDefault();
                        playHighestCard('spades');
                        return;
                    }
                    if (e.ctrlKey && e.key === '2' && !e.altKey) {
                        e.preventDefault();
                        playHighestCard('hearts');
                        return;
                    }
                    if (e.ctrlKey && e.key === '3' && !e.altKey) {
                        e.preventDefault();
                        playHighestCard('diamonds');
                        return;
                    }
                    if (e.ctrlKey && e.key === '4' && !e.altKey) {
                        e.preventDefault();
                        playHighestCard('clubs');
                        return;
                    }

                    // Card playing shortcuts - low cards
                    if (e.altKey && e.key === '1') {
                        e.preventDefault();
                        playLowestCard('spades');
                        return;
                    }
                    if (e.altKey && e.key === '2') {
                        e.preventDefault();
                        playLowestCard('hearts');
                        return;
                    }
                    if (e.altKey && e.key === '3') {
                        e.preventDefault();
                        playLowestCard('diamonds');
                        return;
                    }
                    if (e.altKey && e.key === '4') {
                        e.preventDefault();
                        playLowestCard('clubs');
                        return;
                    }

                    // Bidding shortcuts
                    if (e.altKey && e.key.toLowerCase() === 'p') {
                        e.preventDefault();
                        if (gameState && gameState.gamePhase === 'bidding' && 
                            biddingState && biddingState.currentBidder === myPosition) {
                            makeBid('P');
                        }
                        return;
                    }

                    if (e.altKey && e.key.toLowerCase() === 'm') {
                        e.preventDefault();
                        leaveGameFromGame();
                        return;
                    }
                    
                    // Handle bidding level selection (1-7)
                    if (['1', '2', '3', '4', '5', '6', '7'].includes(e.key) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                        if (gameState && gameState.gamePhase === 'bidding' && 
                            biddingState && biddingState.currentBidder === myPosition) {
                            e.preventDefault();
                            uiState.bidLevel = e.key;
                            announceToScreenReader(`Level ${e.key} selected. Press S, H, D, C, or N for suit.`);
                        }
                        return;
                    }
                    
                    // Handle suit selection for bidding
                    const suitKeys = { 's': 'S', 'h': 'H', 'd': 'D', 'c': 'C', 'n': 'N' };
                    if (suitKeys[e.key.toLowerCase()] && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                        if (gameState && gameState.gamePhase === 'bidding' && 
                            biddingState && biddingState.currentBidder === myPosition && uiState.bidLevel) {
                            e.preventDefault();
                            const bid = `${uiState.bidLevel}${suitKeys[e.key.toLowerCase()]}`;
                            makeBid(bid);
                            uiState.bidLevel = null;
                        }
                        return;
                    }
                }

                // Global shortcuts
                if (e.altKey && e.key.toLowerCase() === 'h') {
                    e.preventDefault();
                    toggleHelp();
                    return;
                }

                if (e.altKey && e.key.toLowerCase() === 'i') {
                    e.preventDefault();
                    repeatLastAnnouncement();
                    return;
                }

                if (e.altKey && e.key.toLowerCase() === 'b') {
                    e.preventDefault();
                    if (currentView === 'create-table' || currentView === 'join-table') {
                        showStartMenu();
                    }
                    return;
                }

                // View-specific shortcuts
                if (currentView === 'create-table' && e.altKey && e.key.toLowerCase() === 'c') {
                    e.preventDefault();
                    createTable();
                } else if (currentView === 'join-table' && e.altKey && e.key.toLowerCase() === 'j') {
                    e.preventDefault();
                    joinTable();
                } else if (currentView === 'waiting-room') {
                    if (e.altKey && e.key.toLowerCase() === 's') {
                        e.preventDefault();
                        startGameFromWaiting();
                    } else if (e.altKey && e.key.toLowerCase() === 'l') {
                        e.preventDefault();
                        leaveTableFromWaiting();
                    } else if (e.altKey && e.key.toLowerCase() === 'c') {
                        e.preventDefault();
                        document.getElementById('waiting-chat-input').focus();
                    }
                }
            });
        }

        // SOCKET EVENT HANDLERS
        function setupSocketEventHandlers() {
            socket.on('toista_aani', (data) => {
                if (aanetAlustettu) {
                    toistaAani(data.aaniTyyppi);
                }
            });

            socket.on('tableCreated', (data) => {
                tableCode = data.tableCode;
                resetCreateTableUI();
                announceToScreenReader(`Table ${tableCode} created!`);
                showWaitingRoom();
            });

            socket.on('playerDisconnected', (data) => {
                console.log('Player disconnected:', data);
                
                const message = data.message || `${data.playerName} lost connection`;
                
                if (currentView === 'waiting-room') {
                    addWaitingSystemMessage(message);
                } else if (currentView === 'game') {
                    const chatArea = document.getElementById('game-chat-messages');
                    if (chatArea) {
                        const messageElement = document.createElement('div');
                        messageElement.className = 'chat-message system-message disconnect-warning';
                        messageElement.style.color = '#dc2626';
                        messageElement.style.fontWeight = 'bold';
                        
                        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        messageElement.innerHTML = `
                            <span>[${timestamp}] ⚠️ CONNECTION LOST</span>
                            <div>${message}</div>
                        `;
                        
                        chatArea.appendChild(messageElement);
                        chatArea.scrollTop = chatArea.scrollHeight;
                    }
                }
                
                announceToScreenReader(`Warning: ${message}`);
                
                if (gameState) {
                    renderAllHands();
                }
            });

            socket.on('playerReconnected', (data) => {
                console.log('Player reconnected:', data);
                
                const message = data.message || `${data.playerName} reconnected`;
                
                if (currentView === 'waiting-room') {
                    addWaitingSystemMessage(message);
                } else if (currentView === 'game') {
                    const chatArea = document.getElementById('game-chat-messages');
                    if (chatArea) {
                        const messageElement = document.createElement('div');
                        messageElement.className = 'chat-message system-message reconnect-success';
                        messageElement.style.color = '#16a34a';
                        messageElement.style.fontWeight = 'bold';
                        
                        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        messageElement.innerHTML = `
                            <span>[${timestamp}] ✓ RECONNECTED</span>
                            <div>${message}</div>
                        `;
                        
                        chatArea.appendChild(messageElement);
                        chatArea.scrollTop = chatArea.scrollHeight;
                    }
                }
                
                announceToScreenReader(message);
                
                if (gameState) {
                    renderAllHands();
                }
            });

            socket.on('playerRemovedTimeout', (data) => {
                console.log('Player removed due to timeout:', data);
                
                const message = data.message || 'A player was removed due to connection timeout';
                
                if (currentView === 'waiting-room') {
                    addWaitingSystemMessage(message);
                } else if (currentView === 'game') {
                    const chatArea = document.getElementById('game-chat-messages');
                    if (chatArea) {
                        const messageElement = document.createElement('div');
                        messageElement.className = 'chat-message system-message timeout-warning';
                        messageElement.style.color = '#dc2626';
                        
                        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        messageElement.innerHTML = `
                            <span>[${timestamp}] ⏱️ TIMEOUT</span>
                            <div>${message}</div>
                        `;
                        
                        chatArea.appendChild(messageElement);
                        chatArea.scrollTop = chatArea.scrollHeight;
                    }
                    
                    if (confirm(message + '\n\nDo you want to leave the game?')) {
                        leaveGameFromGame();
                    }
                }
                
                announceToScreenReader(message);
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                showErrorWithAnnouncement('Connection lost. Trying to reconnect...');
                
                document.body.style.opacity = '0.6';
                document.body.style.pointerEvents = 'none';
            });

            socket.on('reconnect', () => {
                console.log('Reconnected to server');
                announceToScreenReader('Connection restored');
                
                document.body.style.opacity = '1';
                document.body.style.pointerEvents = 'auto';
                
                if (tableCode && myName) {
                    console.log('Attempting to rejoin table:', tableCode);
                    socket.emit('getTableInfo', { 
                        tableCode: tableCode, 
                        playerName: myName 
                    });
                }
            });

            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                showErrorWithAnnouncement('Connection problem. Retrying...');
            });

            socket.on('tableInfo', (data) => {
                if (!data) {
                    showErrorWithAnnouncement('Invalid server response');
                    return;
                }
                if (data && data.table) {
                    if (data.table.state === 'playing') {
                        console.warn('Received tableInfo for playing game - ignoring');
                        return;
                    }
                    if (currentView === 'join-table' && data.table) {
                        resetJoinTableUI();
                        
                        const availablePositions = [];
                        for (const [position, player] of Object.entries(data.table.players)) {
                            if (!player) {
                                availablePositions.push(position);
                            }
                        }
                        
                        if (availablePositions.length === 0) {
                            showErrorWithAnnouncement('Table full');
                            return;
                        }
                        
                        tableCode = data.tableCode || document.getElementById('table-code-input').value.trim();
                        showPositionSelection(tableCode, availablePositions, data.table);
                        return;
                    }
                    
                    if (currentView === 'waiting-room') {
                        updateWaitingRoomPositions(data.table);
                    }
                    
                    if (data.playerPosition && !myPosition) {
                        myPosition = data.playerPosition;
                        announceToScreenReader(`You are ${positionName(data.playerPosition)}`);
                    }
                }
            });

            socket.on('gameReconnect', (data) => {
                console.log('Game reconnect received:', data);
                
                tableCode = data.table.code;
                myPosition = data.playerPosition;
                gameState = data.gameState || {};
                biddingState = data.biddingState || {};
                dealNumber = data.dealNumber || 1;
                currentDealer = data.dealer || 'south';
                
                showGameView();
                updateDealInfo();
                
                if (gameState.gamePhase === 'bidding') {
                    document.getElementById('game-bidding-area').style.display = 'block';
                    renderBiddingUI();
                    announceToScreenReader(`Reconnected to game. Bidding phase. ${positionName(biddingState.currentBidder || 'unknown')}'s turn.`);
                } else if (gameState.gamePhase === 'play') {
                    document.getElementById('game-bidding-area').style.display = 'none';
                    updateContractDisplay();
                    const currentPlayerName = positionName(gameState.currentPlayer || 'unknown');
                    announceToScreenReader(`Reconnected to game. Playing ${formatContract(gameState.contract)}. ${currentPlayerName}'s turn.`);
                } else if (gameState.gamePhase === 'end') {
                    document.getElementById('game-bidding-area').style.display = 'none';
                    document.getElementById('game-new-game-button').style.display = 'block';
                    announceToScreenReader('Reconnected to game. Game has ended.');
                }
                
                updateGameUI();
                
                console.log('Game reconnect complete');
            });

            socket.on('playerJoined', (data) => {
                if (selectedJoinPosition && data.position === selectedJoinPosition) {
                    myPosition = data.position;
                    showWaitingRoom();
                    
                    if (data && data.table) {
                        updateWaitingRoomPositions(data.table);
                    }
                } else if (data && data.table && currentView === 'waiting-room') {
                    updateWaitingRoomPositions(data.table);
                }
                
                if (data && data.playerName && data.position) {
                    addWaitingSystemMessage(`${data.playerName} joined as ${positionName(data.position)}`);
                }
            });

            socket.on('playerLeft', (data) => {
                if (data && data.table && currentView === 'waiting-room') {
updateWaitingRoomPositions(data.table);
                    if (data.position) {
                        addWaitingSystemMessage(`Player left from ${positionName(data.position)}`);
                    }
                }
            });

            socket.on('gameStarted', (data) => {
                gameState = data.gameState || {};
                biddingState = data.biddingState || {};
                dealNumber = data.dealNumber || 1;
                currentDealer = data.dealer || 'south';
                updateDealInfo();

                gameState.gamePhase = 'bidding';
                
                showGameView();
                updateGameUI();
                renderBiddingUI();
                
announceToScreenReader(`Board ${dealNumber}. Dealer ${positionName(currentDealer)}.`);
            });

            socket.on('yourCards', (data) => {
                myPosition = data.position;
                if (!gameState) gameState = {};
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                renderAllHands();
                toistaAani('deal');
            });

            socket.on('dummyRevealed', (data) => {
                if (gameState && data.dummyCards && data.dummyPosition) {
                    if (!gameState.hands) gameState.hands = {};
                    gameState.hands[data.dummyPosition] = data.dummyCards;
                    renderAllHands();
                }
            });

            socket.on('bidMade', (data) => {
                biddingState = data.biddingState;
                renderBiddingUI();
                
                const bidText = data.bid === 'P' ? 'passes' : 
                              data.bid === 'X' ? 'doubles' : 
                              data.bid === 'XX' ? 'redoubles' : `bids ${formatBid(data.bid)}`;
                announceToScreenReader(`${positionName(data.position)} ${bidText}`);
            });

            socket.on('biddingComplete', (data) => {
                gameState.contract = data.contract;
                gameState.declarer = data.declarer;
                gameState.dummy = data.dummy;
                gameState.trumpSuit = data.trumpSuit;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gamePhase = 'play';
                
                if (biddingState) {
                    biddingState.biddingComplete = true;
                }
                
                document.getElementById('game-bidding-area').style.display = 'none';
                updateGameUI();
                renderAllHands();
                
                const contractMessage = `Contract: ${formatContract(data.contract)} by ${positionName(data.declarer)}. ${positionName(data.currentPlayer)} leads.`;
                
                if (data.declarer === myPosition) {
                    announceToScreenReader(contractMessage + ' You control dummy.');
                } else {
                    announceToScreenReader(contractMessage);
                }
            });

            socket.on('playPhaseCards', (data) => {
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                
                if (data.dummyCards) {
                    gameState.hands[gameState.dummy] = data.dummyCards;
                    announceToScreenReader('Dummy visible');
                }
                
                renderAllHands();
            });

socket.on('cardPlayed', (data) => {
    
    if (!gameState.currentTrick) gameState.currentTrick = [];
    
    // Päivitä tikki
    gameState.currentTrick = data.currentTrick;
    
    if (gameState.hands[data.position]) {
        const suitCards = gameState.hands[data.position][data.suit];
        if (suitCards) {
            const index = suitCards.indexOf(data.card);
            if (index > -1) {
                suitCards.splice(index, 1);
            }
        }
    }
    
    renderAllHands();
    updateCurrentTrickDisplay();

    announceToScreenReader(`${positionName(data.position)} ${getSuitName(data.suit)} ${data.card}`);
});

socket.on('trickComplete', (data) => {
    
    gameState.tricks = data.tricks;
    gameState.currentPlayer = data.nextPlayer;
    
    updateGameUI();
    
    const winner = positionName(data.winner);
    const next = positionName(data.nextPlayer);
    
    const isUserNext = (data.nextPlayer === myPosition) || 
                     (data.nextPlayer === gameState.dummy && gameState.declarer === myPosition);
    
    const message = isUserNext ? `${winner} won. Your turn.` : `${winner} won. ${next} plays.`;
    
    announceToScreenReader(message);
    updateStatus();
});

            socket.on('nextPlayer', (data) => {
                gameState.currentPlayer = data.currentPlayer;
                updateGameUI();
                renderAllHands();
            });

            socket.on('gameOver', (data) => {
                gameState.gamePhase = 'end';
                gameState.tricks = data.tricks;
                
                announceToScreenReader(data.message);
                document.getElementById('game-new-game-button').style.display = 'block';
            });

            socket.on('newDealStarted', (data) => {
                dealNumber = data.dealNumber;
                currentDealer = data.dealer;
                updateDealInfo();
                
                gameState = data.gameState || {};
                biddingState = data.biddingState || {};
                gameState.gamePhase = 'bidding';
                
                updateGameUI();
                renderBiddingUI();
                
                document.getElementById('game-bidding-area').style.display = 'block';
                
announceToScreenReader(`Board ${dealNumber}. Dealer ${positionName(currentDealer)}.`);
            });

            socket.on('dealError', (data) => {
                showErrorWithAnnouncement(data.message);
                document.getElementById('game-new-game-button').style.display = 'block';
            });

            socket.on('chatMessage', (data) => {
                if (currentView === 'waiting-room') {
                    addWaitingChatMessage(data.sender, data.position, data.message);
                }
            });

            socket.on('error', (data) => {
                const message = data && data.message ? data.message : 'Error occurred';
                showErrorWithAnnouncement(message);
                
                resetCreateTableUI();
                resetJoinTableUI();
            });
        }

        // INITIALIZATION
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('aanetKaytossa').addEventListener('change', muutaAaniAsetukset);
            document.getElementById('useSynthesizer').addEventListener('change', muutaSyntetisaattoriAsetukset);

            setupKeyboardListeners();
            connectToServer();
            setupSocketEventHandlers();
            
            document.getElementById('table-code-input').addEventListener('input', function() {
                this.value = this.value.replace(/\D/g, '');
                if (this.value.length > 4) {
                    this.value = this.value.substring(0, 4);
                }
            });
            
            // Form submissions
            ['create-name-input', 'table-name-input'].forEach((id, index) => {
                document.getElementById(id).addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (index === 0) {
                            document.getElementById('table-name-input').focus();
                        } else {
                            createTable();
                        }
                    }
                });
            });
            
            ['join-name-input', 'table-code-input'].forEach((id, index) => {
                document.getElementById(id).addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (index === 0) {
                            document.getElementById('table-code-input').focus();
                        } else {
                            joinTable();
                        }
                    }
                });
            });
            
            // Chat inputs
            ['waiting-chat-input', 'game-chat-input'].forEach(id => {
                document.getElementById(id).addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (id === 'waiting-chat-input') {
                            sendWaitingChatMessage();
                        } else {
                            sendGameChatMessage();
                        }
                    }
                });
            });
            
            // Check URL for table code
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code')) {
                showJoinTable();
                document.getElementById('table-code-input').value = urlParams.get('code');
            } else {
                showStartMenu();
            }
            
            // Load saved name
            const savedName = localStorage.getItem('playerName');
            if (savedName) {
                document.getElementById('create-name-input').value = savedName;
                document.getElementById('join-name-input').value = savedName;
            }
            
            // Load saved synthesizer setting
            const savedSynth = localStorage.getItem('useSynthesizer');
            if (savedSynth === 'true') {
                document.getElementById('useSynthesizer').checked = true;
                useSynthesizerEnabled = true;
                document.getElementById('synthStatus').textContent = 'Enabled';
            }
            
            setTimeout(() => {
                announceToScreenReader('AccessibleBridge loaded. Create table or join existing one.');
            }, 1000);
        });
    </script>
</body>
</html>