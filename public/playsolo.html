<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BridgeCircle - Play Solo</title>
    <link rel="stylesheet" href="css/main.css">
    <meta name="description" content="Play bridge against GIB AI opponents">
</head>
<body>
    <div class="container" id="game-view">
        <h1>BridgeCircle - Play Solo</h1>
        
        <!-- ARIA Live area for announcements -->
        <div id="status-announcer" aria-live="polite" class="sr-only"></div>
        
        <!-- Error message container -->
        <div id="error-area" class="error-message" style="display: none;"></div>
        
        <!-- Player management -->
        <section class="section">
            <h2>Players</h2>
            <div class="player-controls" id="players-area">
                <!-- Player information will be added here with JavaScript -->
            </div>
        </section>
        
        <!-- Status message -->
        <div class="status-bar" id="status-area" role="status">
            Welcome to BridgeCircle Solo Play
        </div>
        
        <!-- Action buttons -->
        <div class="action-buttons">
            <button onclick="toggleHelp()" id="toggle-help-button" class="button button-secondary" aria-expanded="false">
                Show Help
            </button>
            
            <button onclick="dealNewCards()" id="deal-button" class="button">
                Deal New Cards
            </button>
            
            <button onclick="navigate('/')" class="button button-secondary">
                Back to Lobby
            </button>
            
            <button onclick="fullscreen()" id="fullscreen-button" class="button button-secondary">
                Full Screen
            </button>
        </div>
        
        <!-- Help section (hidden initially) -->
        <section class="help-section" id="help-section" style="display: none;" role="dialog" aria-labelledby="help-title">
            <h2 id="help-title">Keyboard Shortcuts</h2>
            <ul class="help-list" id="help-list">
                <!-- Will be populated by JavaScript -->
            </ul>
            <button onclick="closeHelp()" id="close-help-button" class="button">
                Close Help
            </button>
        </section>
        
        <!-- Bidding area -->
        <section class="section" id="bidding-area" style="display: none;">
            <h2>Bidding Phase</h2>
            <div id="bidding-history" class="bidding-history">
                <h3>Bidding History</h3>
                <p>No bids yet.</p>
            </div>
            <div id="bidding-controls" class="bidding-controls">
                <h3>Your Bid</h3>
                <p>Waiting for bidding to start...</p>
            </div>
        </section>
        
        <!-- Game table -->
        <div class="game-table">
            <!-- North (top) -->
            <div class="hand north-hand" id="north-hand">
                <h3>North (GIB)</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
            
            <!-- East (right) -->
            <div class="hand east-hand" id="east-hand">
                <h3>East (GIB)</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- Center area -->
            <div class="center-area" id="center-area">
                <!-- Played cards and center information will be added here -->
                <p>Click "Deal New Cards" to start a game</p>
            </div>
            
            <!-- West (left) -->
            <div class="hand west-hand" id="west-hand">
                <h3>West (GIB)</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- South (bottom - player's hand) -->
            <div class="hand south-hand" id="south-hand">
                <h3>Your Hand (South)</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
        </div>
        
<!-- Current trick cards -->
        <section class="section" id="played-cards-area">
            <h2>Current Trick</h2>
            <div id="played-cards-container">
                <p class="text-gray-500">No cards played in current trick yet.</p>
            </div>
        </section>
    </div>
    
    <!-- JavaScript files -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/bridge.js"></script>
    <script>
        let tableCode = null;
        let gameState = null;
        let biddingState = null;
        let myPosition = 'south'; // Always south in solo play
        
        // UI state for keyboard shortcuts
        const uiState = {
            showHelp: false,
            lastAnnouncement: '',
            bidLevel: null, // For bidding shortcuts
        };

        // DOM references
        const elements = {
            statusAnnouncer: document.getElementById('status-announcer'),
            helpSection: document.getElementById('help-section'),
            helpList: document.getElementById('help-list'),
            toggleHelpButton: document.getElementById('toggle-help-button'),
            closeHelpButton: document.getElementById('close-help-button'),
            dealButton: document.getElementById('deal-button'),
            biddingArea: document.getElementById('bidding-area'),
            biddingHistory: document.getElementById('bidding-history'),
            biddingControls: document.getElementById('bidding-controls'),
            northHand: document.getElementById('north-hand'),
            eastHand: document.getElementById('east-hand'),
            westHand: document.getElementById('west-hand'),
            southHand: document.getElementById('south-hand'),
            centerArea: document.getElementById('center-area'),
            playedCardsContainer: document.getElementById('played-cards-container')
        };

        // ANNOUNCEMENT SYSTEM
        const announcementQueue = {
            queue: [],
            processing: false,
            currentTimeout: null,

            add(message) {
                uiState.lastAnnouncement = message;
                this.queue.push({
                    message: message,
                    timestamp: Date.now(),
                    estimatedDuration: this.estimateDuration(message)
                });

                if (!this.processing) {
                    this.processNext();
                }
            },

            estimateDuration(message) {
                const baseRate = 150;
                const minDuration = 2000;
                const maxDuration = 2000;
                let estimated = message.length * baseRate;
                const punctuationCount = (message.match(/[.!?;,]/g) || []).length;
                estimated += punctuationCount * 400;
                return Math.max(minDuration, Math.min(maxDuration, estimated));
            },

            processNext() {
                if (this.queue.length === 0) {
                    this.processing = false;
                    return;
                }

                this.processing = true;
                const announcement = this.queue.shift();
                elements.statusAnnouncer.textContent = '';

                setTimeout(() => {
                    elements.statusAnnouncer.textContent = announcement.message;
                    this.currentTimeout = setTimeout(() => {
                        this.processNext();
                    }, announcement.estimatedDuration);
                }, 100);
            },

            clear() {
                this.queue = [];
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                elements.statusAnnouncer.textContent = '';
                this.processing = false;
            },

            repeatLast() {
                if (uiState.lastAnnouncement) {
                    this.clear();
                    this.add(uiState.lastAnnouncement);
                }
            }
        };

        /**
         * Main announcement function
         */
        function announceToScreenReader(message) {
            announcementQueue.add(message);
        }

        /**
         * Show error with both visual and audio feedback
         */
        function showErrorWithAnnouncement(message) {
            showError(message);
            announceToScreenReader(message);
        }

        /**
         * KORJATTU CARD PLAY VALIDATION FUNCTION
         * Varmistaa ett√§ voi pelata dummysta jos on declarer
         */
        function attemptToPlayCard(suit, card, fromPosition) {
            console.log('Attempting to play card:', { suit, card, fromPosition, gameState });
            
            // Basic checks first
            if (!tableCode) {
                showErrorWithAnnouncement('No game in progress.');
                return;
            }
            
            if (!gameState) {
                showErrorWithAnnouncement('Game state not available.');
                return;
            }
            
            if (gameState.gamePhase !== 'play') {
                showErrorWithAnnouncement('Game is not in play phase.');
                return;
            }
            
            // Determine which position we're trying to play from
            const actualPosition = fromPosition || myPosition;
            
            // Check if it's the right player's turn
            const currentPlayer = gameState.currentPlayer;
            console.log('Current player:', currentPlayer, 'Trying to play from:', actualPosition);
            console.log('Declarer:', gameState.declarer, 'Dummy:', gameState.dummy);
            
            // KORJATTU VALIDOINTI: Salli pelaaminen jos:
            // 1. Nykyinen pelaaja on 'south' ja pelataan 'south':sta
            // 2. Nykyinen pelaaja on 'north' ja olemme declarer ('south') ja 'north' on dummy
            
            let isValidTurn = false;
            
            if (currentPlayer === 'south' && actualPosition === 'south') {
                isValidTurn = true;
                console.log('Valid: Playing from south on south turn');
            } else if (currentPlayer === 'north' && actualPosition === 'north') {
                // Tarkista voiko kontrolloidaimmy√§
                if (gameState.declarer === 'south' && gameState.dummy === 'north') {
                    isValidTurn = true;
                    console.log('Valid: Playing from north (dummy) as declarer');
                } else {
                    console.log('Invalid: Cannot control north - declarer:', gameState.declarer, 'dummy:', gameState.dummy);
                }
            } else {
                console.log('Invalid: Wrong turn or position');
            }
            
            if (!isValidTurn) {
                const currentPlayerName = getPositionName(currentPlayer);
                showErrorWithAnnouncement(`It's ${currentPlayerName}'s turn to play, not yours.`);
                return;
            }
            
            // Check if we have the card
            const hand = gameState.hands[actualPosition];
            if (!hand || !hand[suit] || !hand[suit].includes(card)) {
                showErrorWithAnnouncement(`You don't have the ${getSuitName(suit)} ${card}.`);
                return;
            }
            
            // Check suit following rules
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    showErrorWithAnnouncement(`You must follow suit and play a ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            // All validations passed - play the card
            console.log('All validations passed, playing card');
            sendCardToServer(suit, card, actualPosition);
        }
        
        /**
         * Send card play to server
         */
        function sendCardToServer(suit, card, position) {
            socket.emit('playCard', {
                tableCode: tableCode,
                position: position,
                suit: suit,
                card: card
            });
        }

        /**
         * UUSI OMINAISUUS: Siirt√§√§ fokuksen automaattisesti pyydetyn maan pienimm√§lle kortille
         * kun joku pelaa kortin ja siit√§ tulee uusi lead suit
         */
        function autoFocusOnLeadSuit() {
            // Tarkista ett√§ on pelivaihe ja meill√§ on tiedot k√§siss√§
            if (!gameState || gameState.gamePhase !== 'play' || !gameState.hands) {
                return;
            }
            
            // Tarkista ett√§ tikiss√§ on kortteja ja voimme m√§√§ritt√§√§ lead suitin
            if (!gameState.currentTrick || gameState.currentTrick.length === 0) {
                return;
            }
            
            const leadSuit = gameState.currentTrick[0].suit;
            const currentPlayer = gameState.currentPlayer;
            
            // KORJATTU: Tarkista ett√§ voimme kontrolloida nykyist√§ pelaajaa
            const canControlCurrentPlayer = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControlCurrentPlayer) {
                console.log('Cannot control current player for auto-focus:', currentPlayer);
                return;
            }
            
            // Hae nykyisen pelaajan k√§si
            const hand = gameState.hands[currentPlayer];
            if (!hand || !hand[leadSuit] || hand[leadSuit].length === 0) {
                // Ei ole pyydetyn maan kortteja, ei siirret√§ fokusta
                console.log('No cards in lead suit for auto-focus:', leadSuit);
                return;
            }
            
            // Etsi pienin kortti lead suitista
            const lowestCard = findLowestCard(hand[leadSuit]);
            if (!lowestCard) {
                return;
            }
            
            // Etsi oikea k√§si-elementti
            const handElement = currentPlayer === 'south' ? elements.southHand : elements.northHand;
            
            // Etsi kortin painike
            const cardButton = handElement.querySelector(`button[data-suit="${leadSuit}"][data-card="${lowestCard}"]`);
            
            if (cardButton) {
                // Siirret√§√§n fokus lyhyen viiveen j√§lkeen (annetaan render√∂innin valmistua)
                setTimeout(() => {
                    cardButton.focus();
                    console.log(`Auto-focused on ${getSuitName(leadSuit)} ${lowestCard} for player ${currentPlayer}`);
                    
                    // Ilmoita k√§ytt√§j√§lle ett√§ fokus siirtyi
                    announceToScreenReader(`Focus moved to ${getSuitName(leadSuit)} ${lowestCard}.`);
                }, 250);
            }
        }

        /**
         * Etsii pienimm√§n kortin listasta k√§ytt√§en bridge-j√§rjestyst√§
         */
        function findLowestCard(cards) {
            if (!cards || cards.length === 0) {
                return null;
            }
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            
            // J√§rjest√§ kortit arvon mukaan pienimm√§st√§ suurimpaan
            const sortedCards = [...cards].sort((a, b) => {
                return cardValues.indexOf(a) - cardValues.indexOf(b);
            });
            
            return sortedCards[0];
        }

        /**
         * Etsii suurimman kortin listasta k√§ytt√§en bridge-j√§rjestyst√§
         */
        function findHighestCard(cards) {
            if (!cards || cards.length === 0) {
                return null;
            }
            
            const cardValues = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            
            // J√§rjest√§ kortit arvon mukaan suurimmasta pienimp√§√§n
            const sortedCards = [...cards].sort((a, b) => {
                return cardValues.indexOf(b) - cardValues.indexOf(a);
            });
            
            return sortedCards[0];
        }

        // Keyboard shortcuts configuration
        const keyboardShortcuts = [
            // Card viewing shortcuts (Own cards)
            { key: 'a', alt: true, description: 'Read your spades', action: () => announceHandSuit('south', 'spades') },
            { key: 's', alt: true, description: 'Read your hearts', action: () => announceHandSuit('south', 'hearts') },
            { key: 'd', alt: true, description: 'Read your diamonds', action: () => announceHandSuit('south', 'diamonds') },
            { key: 'f', alt: true, description: 'Read your clubs', action: () => announceHandSuit('south', 'clubs') },
            { key: 'g', alt: true, description: 'Read all your cards', action: () => announceEntireHand('south') },

// Card viewing shortcuts (Dummy's cards) - SECURE VERSION
{ key: 'q', alt: true, description: 'Read dummy spades', action: () => {
    if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
        announceHandSuit(gameState.dummy, 'spades');
    } else {
        announceToScreenReader('Cannot view dummy spades at this time.');
    }
}},
{ key: 'w', alt: true, description: 'Read dummy hearts', action: () => {
    if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
        announceHandSuit(gameState.dummy, 'hearts');
    } else {
        announceToScreenReader('Cannot view dummy hearts at this time.');
    }
}},
{ key: 'e', alt: true, description: 'Read dummy diamonds', action: () => {
    if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
        announceHandSuit(gameState.dummy, 'diamonds');
    } else {
        announceToScreenReader('Cannot view dummy diamonds at this time.');
    }
}},
{ key: 'r', alt: true, description: 'Read dummy clubs', action: () => {
    if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
        announceHandSuit(gameState.dummy, 'clubs');
    } else {
        announceToScreenReader('Cannot view dummy clubs at this time.');
    }
}},
{ key: 't', alt: true, description: 'Read all dummy cards', action: () => {
    if (gameState?.dummy && canViewHandCards(gameState.dummy)) {
        announceEntireHand(gameState.dummy);
    } else {
        announceToScreenReader('Cannot view all dummy cards at this time.');
    }
}},

            // Game state shortcuts
            { key: 'z', alt: true, description: 'Read current trick', action: () => announceCurrentTrick() },
            { key: 'x', alt: true, description: 'Read game state', action: () => announceGameState() },
            { key: 'c', alt: true, description: 'Announce current player', action: () => announceCurrentPlayer() },
            { key: 'v', alt: true, description: 'Read last played trick', action: () => announceLastTrick() },
            
            // Bidding shortcuts
            { key: 'p', alt: true, description: 'Bid Pass', action: () => makeBidShortcut('P') },
            { key: 'd', alt: true, description: 'Bid Double', action: () => makeBidShortcut('X') },
            { key: 'f', alt: true, description: 'Bid Redouble', action: () => makeBidShortcut('XX') },
            
            // Card playing shortcuts - high cards only
            { key: '1', ctrl: true, description: 'Play highest spade', action: () => playHighestCard('spades') },
            { key: '2', ctrl: true, description: 'Play highest heart', action: () => playHighestCard('hearts') },
            { key: '3', ctrl: true, description: 'Play highest diamond', action: () => playHighestCard('diamonds') },
            { key: '4', ctrl: true, description: 'Play highest club', action: () => playHighestCard('clubs') },
            
            // General shortcuts
            { key: 'h', alt: true, description: 'Show/hide help', action: () => toggleHelp() },
            { key: 'n', alt: true, description: 'Deal new cards', action: () => dealNewCards() },
            { key: 'i', alt: true, description: 'Repeat last announcement', action: () => repeatLastAnnouncement() },
            { key: 'o', alt: true, description: 'Announce score', action: () => announceScore() },
            { key: 'm', alt: true, description: 'Restart game', action: () => restartGame() },
        ];

        // Simple number keys for bidding levels
        const bidLevelKeys = ['1', '2', '3', '4', '5', '6', '7'];
        // Simple suit keys for bidding
        const bidSuitKeys = {
            's': 'S', // Spades
            'h': 'H', // Hearts
            'd': 'D', // Diamonds
            'c': 'C', // Clubs
            'n': 'N'  // No Trump
        };

        /**
         * Clear announcement queue
         */
        function clearAnnouncementQueue() {
            announcementQueue.clear();
            announceToScreenReader("Announcement queue cleared.");
        }

        /**
         * Repeat last announcement
         */
        function repeatLastAnnouncement() {
            if (uiState.lastAnnouncement) {
                announcementQueue.repeatLast();
            } else {
                announceToScreenReader("No announcement to repeat.");
            }
        }

        /**
         * Renders the help list
         */
        function renderHelpList() {
            elements.helpList.innerHTML = '';
            
            keyboardShortcuts.forEach(shortcut => {
                if (!shortcut.action) return;
                
                const modifiers = [];
                if (shortcut.alt) modifiers.push('Alt');
                if (shortcut.shift) modifiers.push('Shift');
                if (shortcut.ctrl) modifiers.push('Ctrl');
                
                const keyCombo = modifiers.length > 0 
                    ? `${modifiers.join('+')} + ${shortcut.key.toUpperCase()}`
                    : shortcut.key.toUpperCase();
                    
                const li = document.createElement('li');
                li.innerHTML = `<strong>${keyCombo}</strong>: ${shortcut.description}`;
                elements.helpList.appendChild(li);
            });
            
            // Add the dual-purpose keys
            const gamePhase = gameState ? gameState.gamePhase : 'setup';
            const phaseText = gamePhase === 'bidding' ? 'Select suit for bidding' : 
                             gamePhase === 'play' ? 'Focus on lowest card of suit' : 
                             'Depends on game phase';
            
            const dualPurposeKeys = [
                { key: 'S', desc: 'Spades' },
                { key: 'H', desc: 'Hearts' },
                { key: 'D', desc: 'Diamonds' },
                { key: 'C', desc: 'Clubs' }
            ];
            
            dualPurposeKeys.forEach(key => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${key.key}</strong>: ${phaseText} (${key.desc})`;
                elements.helpList.appendChild(li);
            });
            
            if (gamePhase === 'bidding') {
                const li = document.createElement('li');
                li.innerHTML = `<strong>N</strong>: Select No Trump for bidding`;
                elements.helpList.appendChild(li);
            }
        }

        /**
         * Announces cards in a specific suit from a hand
         */
        function announceHandSuit(position, suit) {
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                const message = `${getPositionName(position)} has no ${getSuitName(suit)}s.`;
                announceToScreenReader(message);
                return;
            }
            
            const message = `${getPositionName(position)}'s ${getSuitName(suit)}s: ${cards.join(', ')}`;
            announceToScreenReader(message);
        }

/**
 * Check if we can view cards for a position
 */
function canViewHandCards(position) {
    if (position === 'south') return true; // Oma k√§si n√§kyy aina
    
    // Dummy n√§kyy jos peli on pelivaiheessa ja position on dummy
    if (gameState && 
        gameState.gamePhase === 'play' && 
        gameState.dummy === position) {
        return true; // Yksinkertaisesti: dummy n√§kyy aina pelivaiheessa
    }
    
    return false;
}

function canPlayFromPosition(position) {
    if (!gameState || gameState.gamePhase !== 'play') return false;
    
    // Always can play from south (our position)
    if (position === 'south') return true;
    
    // KORJATTU: Can play from dummy if we're declarer and position is dummy
    if (position === gameState.dummy && gameState.declarer === 'south') {
        return true;
    }
    
    return false;
}

        /**
         * KORJATTU: Check if it's our turn to play from a specific position
         */
        function isOurTurnToPlay(position) {
            if (!gameState || gameState.gamePhase !== 'play') return false;
            
            const currentPlayer = gameState.currentPlayer;
            
            // Direct control: it's our position and our turn
            if (position === 'south' && currentPlayer === 'south') return true;
            
            // KORJATTU: Dummy control: we're declarer, it's dummy's turn, and we can control dummy
            if (position === 'north' && currentPlayer === 'north' && 
                gameState.declarer === 'south' && gameState.dummy === 'north') {
                return true;
            }
            
            return false;
        }

        /**
         * Announces all cards in a hand
         */
        function announceEntireHand(position) {
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            let message = `${getPositionName(position)}'s hand: `;
            
            for (const suit of ['spades', 'hearts', 'diamonds', 'clubs']) {
                const cards = hand[suit] || [];
                if (cards.length > 0) {
                    message += `${getSuitName(suit)}s: ${cards.join(', ')}. `;
                } else {
                    message += `No ${getSuitName(suit)}s. `;
                }
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the current trick
         */
        function announceCurrentTrick() {
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader('The game is not in play phase yet.');
                return;
            }
            
            if (!gameState.currentTrick || gameState.currentTrick.length === 0) {
                announceToScreenReader('No cards played in the current trick yet.');
                return;
            }
            
            let message = 'Current trick: ';
            
            for (const card of gameState.currentTrick) {
                message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the game state
         */
        function announceGameState() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            let message = `Game phase: ${gameState.gamePhase}. `;
            
            if (gameState.gamePhase === 'play' || gameState.gamePhase === 'end') {
                message += `Contract: ${formatContract(gameState.contract)} by ${getPositionName(gameState.declarer)}. `;
                message += `North-South tricks: ${gameState.tricks.ns}. East-West tricks: ${gameState.tricks.ew}. `;
                message += `Current player: ${getPositionName(gameState.currentPlayer)}.`;
                
                // LIS√ÑTTY: Ilmoita jos olemme declarer
                if (gameState.declarer === 'south') {
                    message += ` You are the declarer and can control both South and North (dummy).`;
                }
            } else if (gameState.gamePhase === 'bidding') {
                message += `Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`;
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the current player
         */
        function announceCurrentPlayer() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            if (gameState.gamePhase === 'play') {
                let message = `Current player: ${getPositionName(gameState.currentPlayer)}.`;
                
                // LIS√ÑTTY: Selit√§ jos voimme kontrolloida pelaajaa
                if (gameState.currentPlayer === 'north' && gameState.declarer === 'south') {
                    message += ` You control North as the declarer.`;
                }
                
                announceToScreenReader(message);
            } else if (gameState.gamePhase === 'bidding') {
                announceToScreenReader(`Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`);
            } else {
                announceToScreenReader(`Game phase: ${gameState.gamePhase}. No current player.`);
            }
        }

/**
         * Announces the last completed trick (modified for current trick only mode)
         */
        function announceLastTrick() {
            // P√ÑIVITETTY: Koska n√§yt√§mme vain nykyisen tikin, edelliset tikit eiv√§t ole n√§kyviss√§
            // T√§m√§ on realistista - oikeassa bridgess√§ edelliset tikit ker√§t√§√§n pois eik√§ niit√§ n√§e
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader('The game is not in play phase yet.');
                return;
            }
            
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                // Jos nykyisess√§ tikiss√§ on kortteja, anna ne tiedoksi
                let message = 'Current trick in progress: ';
                for (const card of gameState.currentTrick) {
                    message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
                }
                announceToScreenReader(message);
            } else {
                // Ei edellist√§ tikki√§ n√§kyviss√§ (realistinen bridgen simulaatio)
                announceToScreenReader('Previous tricks are not visible - they have been collected. Only the current trick is shown.');
            }
        }

        /**
         * Makes a bid using keyboard shortcut
         */
        function makeBidShortcut(bid) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south') {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            if (!['P', 'X', 'XX'].includes(bid)) {
                announceToScreenReader('Invalid bid format.');
                return;
            }
            
            makeBid(bid);
        }

        /**
         * Handles bid level selection for two-step bidding
         */
        function handleBidLevelKey(level) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south') {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            uiState.bidLevel = level;
            announceToScreenReader(`Bid level ${level} selected. Press S, H, D, C, or N to select suit.`);
        }

        /**
         * Handles bid suit selection to complete a bid
         */
        function handleBidSuitKey(suit) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south' || !uiState.bidLevel) {
                if (!uiState.bidLevel) {
                    announceToScreenReader("Please select a bid level 1 through 7 first.");
                } else {
                    announceToScreenReader("It's not your turn to bid.");
                }
                return;
            }
            
            const bid = `${uiState.bidLevel}${suit}`;
            
            if (!isValidBid(bid, biddingState.highestBid)) {
                announceToScreenReader(`Invalid bid: ${uiState.bidLevel} ${getSuitNameForBid(suit)}.`);
                uiState.bidLevel = null;
                return;
            }
            
            makeBid(bid);
            uiState.bidLevel = null;
        }

        /**
         * Check if bid is valid
         */
        function isValidBid(bid, highestBid) {
            if (bid === 'P') return true;
            if (bid === 'X' || bid === 'XX') return true;
            if (!highestBid) return true;
            
            const bidLevel = parseInt(bid.charAt(0));
            const bidSuit = bid.charAt(1);
            const highestLevel = parseInt(highestBid.charAt(0));
            const highestSuit = highestBid.charAt(1);
            
            const suits = ['C', 'D', 'H', 'S', 'N'];
            const bidSuitIndex = suits.indexOf(bidSuit);
            const highestSuitIndex = suits.indexOf(highestSuit);
            
            if (bidLevel > highestLevel) return true;
            if (bidLevel === highestLevel && bidSuitIndex > highestSuitIndex) return true;
            
            return false;
        }

        /**
         * Gets a suit name for bid announcement
         */
        function getSuitNameForBid(suit) {
            switch(suit) {
                case 'C': return 'Clubs';
                case 'D': return 'Diamonds';
                case 'H': return 'Hearts';
                case 'S': return 'Spades';
                case 'N': return 'No Trump';
                default: return suit;
            }
        }

        /**
         * Plays the highest card of a suit
         */
        function playHighestCard(suit) {
            const currentPlayer = gameState?.currentPlayer;
            
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader("Game is not in play phase.");
                return;
            }
            
            // KORJATTU: Check if we can control the current player
            const canControl = canPlayFromPosition(currentPlayer) && isOurTurnToPlay(currentPlayer);
            
            if (!canControl) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
            // Check if player must follow suit
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            // Get the highest card
            const highestCard = findHighestCard(cards);
            
            if (highestCard) {
                // Play the card
                attemptToPlayCard(suit, highestCard, currentPlayer);
            }
        }

        /**
         * Announces the current score
         */
        function announceScore() {
            if (gameState && (gameState.gamePhase === 'play' || gameState.gamePhase === 'end')) {
                announceToScreenReader(`North-South: ${gameState.tricks.ns} tricks. East-West: ${gameState.tricks.ew} tricks.`);
            } else {
                announceToScreenReader("No score available yet.");
            }
        }

        /**
         * Restarts the game
         */
        function restartGame() {
            if (confirm("Are you sure you want to restart the game?")) {
                dealNewCards();
                announceToScreenReader('Game restarted. New cards dealt.');
            }
        }

        /**
         * Helper functions for naming
         */
        function getPositionName(position) {
            switch(position) {
                case 'north': return 'North';
                case 'east': return 'East';
                case 'south': return 'South';
                case 'west': return 'West';
                default: return position || 'Unknown';
            }
        }

        function getSuitName(suit) {
            const names = {
                spades: 'Spades',
                hearts: 'Hearts',
                diamonds: 'Diamonds',
                clubs: 'Clubs'
            };
            return names[suit] || suit;
        }

        function getSuitSymbol(suit) {
            const symbols = { 
                spades: '‚ô†', 
                hearts: '‚ô•', 
                diamonds: '‚ô¶', 
                clubs: '‚ô£' 
            };
            return symbols[suit] || suit;
        }

        // Show help
        function showHelp() {
            uiState.showHelp = true;
            toggleHelp();
        }
        
        // Close help
        function closeHelp() {
            uiState.showHelp = false;
            toggleHelp();
        }

        /**
         * Show/hide help section
         */
        function toggleHelp() {
            uiState.showHelp = !uiState.showHelp;
            elements.helpSection.style.display = uiState.showHelp ? 'block' : 'none';
            elements.toggleHelpButton.textContent = uiState.showHelp ? 'Hide Help' : 'Show Help';
            elements.toggleHelpButton.setAttribute('aria-expanded', uiState.showHelp);
            
            if (uiState.showHelp) {
                renderHelpList();
            }
        }
        
        // Deal new cards
        function dealNewCards() {
            gameState = null;
            biddingState = null;
            announcementQueue.clear();
            document.getElementById('bidding-area').style.display = 'none';
                        resetPlayedCardsContainer();

            if (tableCode) {
                socket.emit('resetSoloGame', {
                    tableCode: tableCode
                });
            } else {
                initializeSoloGame();
            }
            
            announceToScreenReader('Dealing new cards...');
        }
        
        // Fullscreen mode
        function fullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error entering fullscreen mode: ${err.message}`);
                });
                document.getElementById('fullscreen-button').textContent = 'Exit Fullscreen';
            } else {
                document.exitFullscreen();
                document.getElementById('fullscreen-button').textContent = 'Full Screen';
            }
        }
        
        // Initialize solo game
        function initializeSoloGame() {
            const playerName = localStorage.getItem('playerName') || 'Player';
            
            socket.emit('createSoloGame', {
                playerName: playerName
            });
        }
        
        /**
         * KORJATTU: Renders all hands correctly based on declarer/dummy status
         */
        function renderAllHands() {
            if (!gameState || !gameState.hands) return;
            
            // Render all positions that we have cards for
            for (const position of ['north', 'south', 'east', 'west']) {
                if (gameState.hands[position]) {
                    renderHand(position, gameState.hands[position]);
                }
            }
        }
        
        // RENDER HAND - KORJATTU VERSIO
        function renderHand(position, hand) {
            const element = position === 'north' ? document.getElementById('north-hand') :
                           position === 'south' ? document.getElementById('south-hand') :
                           position === 'east' ? document.getElementById('east-hand') :
                           document.getElementById('west-hand');
            
            if (!element || !hand) return;
            
            // KORJATTU: N√§yt√§ oikea tyyppi positiolle
            let positionType = 'GIB';
            if (position === 'south') {
                positionType = 'You';
            } else if (position === 'north' && gameState && gameState.declarer === 'south') {
                positionType = 'Dummy (You control)';
            }
            
            let html = `<h3>${position === 'south' ? 'Your Hand (South)' : positionName(position)} 
                      ${position === 'south' ? '' : `(${positionType})`}</h3>`;
            
            // Check if we can view cards
            const canViewCards = canViewHandCards(position);
            
            if (!canViewCards) {
                html += `<p>Cards will be visible when play begins, if South or North is declarer.</p>`;
                element.innerHTML = html;
                return;
            }
            
            // KORJATTU: Check if we can play from this position
            const canPlayFromThisPosition = canPlayFromPosition(position);
            const isPlayPhase = gameState && gameState.gamePhase === 'play';
            
            console.log(`Rendering ${position}: canPlay=${canPlayFromThisPosition}, isPlayPhase=${isPlayPhase}, declarer=${gameState?.declarer}, dummy=${gameState?.dummy}`);
            
            Object.entries(hand).forEach(([suit, cards]) => {
                const suitClass = `suit-${suit}`;
                
                html += `
                    <div class="suit-row">
                        <div class="suit-label ${suitClass}">
                            ${suitSymbol(suit)} ${suitName(suit)}
                        </div>
                        <div class="cards-buttons">
                `;
                
                if (cards.length > 0) {
                    cards.forEach(card => {
                        const cardClass = `card-${suit}`;
                        
                        // KORJATTU: Make buttons if we can play from this position AND it's play phase
                        if (isPlayPhase && canPlayFromThisPosition) {
                            html += `
                                <button 
                                    class="card-button ${cardClass}"
                                    data-suit="${suit}"
                                    data-card="${card}"
                                    onclick="attemptToPlayCard('${suit}', '${card}', '${position}')"
                                    aria-label="Play ${suitName(suit)} ${card}"
                                >
                                    ${card}
                                </button>
                            `;
                        } else {
                            html += `
                                <span class="card-display ${cardClass}" aria-label="${suitName(suit)} ${card}">
                                    ${card}
                                </span>
                            `;
                        }
                    });
                } else {
                    html += `<span class="text-gray-400">(empty)</span>`;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            element.innerHTML = html;
        }
        
        // Render bidding UI
        function renderBiddingUI() {
            const biddingArea = document.getElementById('bidding-area');
            if (biddingArea) {
                biddingArea.style.display = 'block';
            }
            
            renderBiddingHistory();
            
            if (biddingState && biddingState.currentBidder === myPosition) {
                renderBiddingControls();
            } else {
                const biddingControls = document.getElementById('bidding-controls');
                if (biddingControls) {
                    biddingControls.innerHTML = `
                        <h3>Your Bid</h3>
                        <p>Waiting for ${positionName(biddingState ? biddingState.currentBidder : 'unknown')} to bid...</p>
                    `;
                }
            }
        }
        
        // Render bidding history
        function renderBiddingHistory() {
            const biddingHistory = document.getElementById('bidding-history');
            if (!biddingHistory) return;
            
            let html = '<h3>Bidding History</h3>';
            
            if (!biddingState || !biddingState.bidHistory || biddingState.bidHistory.length === 0) {
                html += '<p>No bids yet.</p>';
            } else {
                html += `
                    <table class="bidding-table">
                        <thead>
                            <tr>
                                <th>West</th>
                                <th>North</th>
                                <th>East</th>
                                <th>South</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                const rounds = [];
                let currentRound = [];
                let dealerIndex = ['west', 'north', 'east', 'south'].indexOf(biddingState.dealer);
                
                for (let i = 0; i < dealerIndex; i++) {
                    currentRound.push(null);
                }
                
                for (const bid of biddingState.bidHistory) {
                    currentRound.push(bid);
                    
                    if (currentRound.length === 4) {
                        rounds.push([...currentRound]);
                        currentRound = [];
                    }
                }
                
                if (currentRound.length > 0) {
                    rounds.push([...currentRound]);
                }
                
                for (const round of rounds) {
                    html += '<tr>';
                    
                    for (let i = 0; i < 4; i++) {
                        const bid = round[i];
                        
                        if (!bid) {
                            html += '<td></td>';
                        } else {
                            const bidText = formatBidForDisplay(bid.bid);
                            html += `<td>${bidText}</td>`;
                        }
                    }
                    
                    html += '</tr>';
                }
                
                html += '</tbody></table>';
            }
            
            biddingHistory.innerHTML = html;
        }
        
        // Render bidding controls
        function renderBiddingControls() {
            const biddingControls = document.getElementById('bidding-controls');
            if (!biddingControls) return;
            
            const possibleBids = getPossibleBids(biddingState ? biddingState.highestBid : null);
            
            let html = '<h3>Your Bid</h3>';
            html += '<div class="bidding-buttons">';
            
            for (const specialBid of ['P', 'X', 'XX']) {
                if (possibleBids.includes(specialBid)) {
                    const bidText = specialBid === 'P' ? 'Pass' : 
                                  specialBid === 'X' ? 'Double (X)' : 'Redouble (XX)';
                    
                    html += `
                        <button class="bid-button" onclick="makeBid('${specialBid}')">
                            ${bidText}
                        </button>
                    `;
                }
            }
            
            const contractBids = possibleBids.filter(bid => !['P', 'X', 'XX'].includes(bid));
            const bidsByLevel = {};
            
            for (const bid of contractBids) {
                const level = bid.charAt(0);
                if (!bidsByLevel[level]) bidsByLevel[level] = [];
                bidsByLevel[level].push(bid);
            }
            
            for (const level in bidsByLevel) {
                html += `<div class="bid-level-group">`;
                
                for (const bid of bidsByLevel[level]) {
                    const suit = bid.charAt(1);
                    let suitSymbol, suitClass;
                    
                    switch(suit) {
                        case 'C': 
                            suitSymbol = '‚ô£'; 
                            suitClass = 'bid-clubs';
                            break;
                        case 'D': 
                            suitSymbol = '‚ô¶'; 
                            suitClass = 'bid-diamonds';
                            break;
                        case 'H': 
                            suitSymbol = '‚ô•'; 
                            suitClass = 'bid-hearts';
                            break;
                        case 'S': 
                            suitSymbol = '‚ô†'; 
                            suitClass = 'bid-spades';
                            break;
                        case 'N': 
                            suitSymbol = 'NT'; 
                            suitClass = 'bid-notrump';
                            break;
                        default: 
                            suitSymbol = suit;
                            suitClass = '';
                    }
                    
                    html += `
                        <button class="bid-button ${suitClass}" onclick="makeBid('${bid}')">
                            ${level}${suitSymbol}
                        </button>
                    `;
                }
                
                html += `</div>`;
            }
            
            html += '</div>';
            html += '<div class="bid-meanings">';
            html += `<p><strong>System:</strong> Natural</p>`;
            html += '</div>';
            
            biddingControls.innerHTML = html;
        }
        
        // Make bid
        function makeBid(bid) {
            if (!tableCode) return;
            
            socket.emit('makeBid', {
                tableCode: tableCode,
                position: myPosition,
                bid: bid
            });
        }
        
        // Get possible bids
        function getPossibleBids(highestBid) {
            const possibleBids = ['P'];
            
            if (highestBid) {
                possibleBids.push('X');
            }
            
            const levels = ['1', '2', '3', '4', '5', '6', '7'];
            const suits = ['C', 'D', 'H', 'S', 'N'];
            
            if (!highestBid) {
                for (const level of levels) {
                    for (const suit of suits) {
                        possibleBids.push(`${level}${suit}`);
                    }
                }
            } else {
                const highestLevel = parseInt(highestBid.charAt(0));
                const highestSuit = highestBid.charAt(1);
                const highestSuitIndex = suits.indexOf(highestSuit);
                
                for (let level = highestLevel; level <= 7; level++) {
                    for (let suitIndex = 0; suitIndex < suits.length; suitIndex++) {
                        if (level === highestLevel && suitIndex <= highestSuitIndex) continue;
                        possibleBids.push(`${level}${suits[suitIndex]}`);
                    }
                }
            }
            
            return possibleBids;
        }
        
        // Format bid for display
        function formatBidForDisplay(bid) {
            if (bid === 'P') return 'Pass';
            if (bid === 'X') return 'X (Double)';
            if (bid === 'XX') return 'XX (Redouble)';
            
            const level = bid.charAt(0);
            const suit = bid.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '‚ô£'; break;
                case 'D': suitSymbol = '‚ô¶'; break;
                case 'H': suitSymbol = '‚ô•'; break;
                case 'S': suitSymbol = '‚ô†'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            return `${level}${suitSymbol}`;
        }
        
        // Update game UI
        function updateGameUI() {
            if (!gameState) return;
            
            const playersArea = document.getElementById('players-area');
            if (playersArea) {
                let html = '';
                
                const positions = ['north', 'east', 'south', 'west'];
                for (const position of positions) {
                    const isCurrentPlayer = gameState.currentPlayer === position;
                    const player = gameState.players[position];
                    const playerName = player ? player.name : positionName(position);
                    let playerType = player ? player.type : 'human';
                    
                    // KORJATTU: N√§yt√§ oikea status dummylle
// KORJATTU: N√§yt√§ oikea status dummylle
// KORJATTU: N√§yt√§ oikea status dummylle
if (position === gameState.dummy && gameState.declarer === 'south') {
    playerType = 'Dummy (You control)';
                    } else if (playerType === 'gib') {
                        playerType = 'GIB';
                    } else {
                        playerType = 'Human';
                    }
                    
                    html += `
                        <div class="player-badge ${isCurrentPlayer ? 'current' : ''}">
                            <div>${positionName(position)}</div>
                            <div>${playerName}</div>
                            <div>${playerType}</div>
                        </div>
                    `;
                }
                
                playersArea.innerHTML = html;
            }
            
            const statusArea = document.getElementById('status-area');
            if (statusArea) {
                if (gameState.gamePhase === 'bidding') {
                    statusArea.textContent = 'Bidding phase';
                } else if (gameState.gamePhase === 'play') {
                    let statusText = `Playing: ${formatContract(gameState.contract)}`;
                    if (gameState.declarer === 'south') {
                        statusText += ' (You are declarer)';
                    }
                    statusArea.textContent = statusText;
                } else {
                    statusArea.textContent = 'BridgeCircle Solo Play';
                }
            }
        }
        
        // Format contract
        function formatContract(contract) {
            if (!contract) return "No contract";
            
            const level = contract.charAt(0);
            const suit = contract.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '‚ô£'; break;
                case 'D': suitSymbol = '‚ô¶'; break;
                case 'H': suitSymbol = '‚ô•'; break;
                case 'S': suitSymbol = '‚ô†'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            let result = `${level}${suitSymbol}`;
            
            if (contract.includes('XX')) {
                result += ' XX';
            } else if (contract.includes('X')) {
                result += ' X';
            }
            
            return result;
        }
        
        // Update center area
        function updateCenterArea() {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.gamePhase === 'play') {
                let html = '<h3>Played Tricks</h3>';
                
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
                
                if (gameState.contract) {
                    html += `<p>Contract: ${formatContract(gameState.contract)}, `;
                    html += `declarer: ${positionName(gameState.declarer)}</p>`;
                }
                
                centerArea.innerHTML = html;
            }
        }
        
        // Update played card
        function updatePlayedCard(position, suit, card) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.currentTrick && gameState.currentTrick.length === 1) {
                centerArea.innerHTML = '<h3>Current Trick</h3>';
            }
            
            const cardElement = document.createElement('div');
            cardElement.className = `played-card ${suit === 'hearts' || suit === 'diamonds' ? 'red-card' : ''}`;
            cardElement.innerHTML = `<span class="player-name">${positionName(position)}:</span> ${suitSymbol(suit)} ${card}`;
            
            centerArea.appendChild(cardElement);
        }
        
        // Show game over
        function showGameOver(message) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            let html = '<h3>Game Over</h3>';
            html += `<p>${message}</p>`;
            
            if (gameState && gameState.tricks) {
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
            }
            
            html += `<button onclick="dealNewCards()" class="button">Deal New Cards</button>`;
            
            centerArea.innerHTML = html;
        }
        /**
         * Update played cards container to show only current trick cards
         */
        function updatePlayedCardsContainer() {
            const container = elements.playedCardsContainer;
            if (!container) return;
            
            if (!gameState || !gameState.currentTrick || gameState.currentTrick.length === 0) {
                container.innerHTML = '<p class="text-gray-500">No cards played in current trick yet.</p>';
                return;
            }
            
            let html = '<div class="current-trick-display">';
            html += '<h3>Current Trick</h3>';
            html += '<div class="trick-cards">';
            
            for (const card of gameState.currentTrick) {
                const suitColor = (card.suit === 'hearts' || card.suit === 'diamonds') ? 'red-card' : 'black-card';
                html += `
                    <div class="played-card-item ${suitColor}">
                        <span class="player-name">${positionName(card.player)}:</span>
                        <span class="card-display">${getSuitSymbol(card.suit)}${card.card}</span>
                    </div>
                `;
            }
            
            html += '</div>';
            
            // Show how many cards are still needed to complete the trick
            const cardsRemaining = 4 - gameState.currentTrick.length;
            if (cardsRemaining > 0) {
                html += `<p class="trick-status">${cardsRemaining} more card${cardsRemaining > 1 ? 's' : ''} needed to complete trick.</p>`;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        /**
         * Reset played cards display for new game
         */
        function resetPlayedCardsContainer() {
            const container = elements.playedCardsContainer;
            if (container) {
                container.innerHTML = '<p class="text-gray-500">No cards played in current trick yet.</p>';
            }
        }

        // Direct function for navigation
        function navigate(page) {
            window.location.href = page;
        }

        /**
         * Set up keyboard event listeners
         */
        function setupKeyboardListeners() {
            document.addEventListener('keydown', (e) => {
                // Process keyboard shortcuts
                for (const shortcut of keyboardShortcuts) {
                    if (shortcut.action && // Skip shortcuts with no action (they're handled separately)
                        e.key.toLowerCase() === shortcut.key.toLowerCase() && 
                        (!shortcut.alt || e.altKey) && 
                        (!shortcut.shift || e.shiftKey) && 
                        (!shortcut.ctrl || e.ctrlKey)) {
                        
                        e.preventDefault();
                        shortcut.action();
                        return;
                    }
                }
                
                // Handle s, h, d, c keys with dual purpose:
                // 1. In bidding phase: suit selection for bidding
                // 2. In play phase: focus on lowest card of that suit
                const suitKey = e.key.toLowerCase();
                if (['s', 'h', 'd', 'c'].includes(suitKey) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    
                    // Check game phase and handle accordingly
                    if (gameState && gameState.gamePhase === 'bidding') {
                        // Bidding phase - use for bid suit selection
                        if (suitKey in bidSuitKeys) {
                            handleBidSuitKey(bidSuitKeys[suitKey]);
                        }
                    }
                    return;
                }
                
                // Handle bidding level selection (1-7)
                if (bidLevelKeys.includes(e.key) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    handleBidLevelKey(e.key);
                    return;
                }
                
                // Handle 'n' key for No Trump in bidding
                if (e.key.toLowerCase() === 'n' && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    if (gameState && gameState.gamePhase === 'bidding') {
                        handleBidSuitKey('N');
                    }
                    return;
                }
            });
        }
        
        // Initialize page when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Set solo mode flag
            window.isSoloMode = true;
            
            // Set up keyboard listeners
            setupKeyboardListeners();
            
            // Connect to server
            connectToServer();
            
            // Initialize solo game
            initializeSoloGame();
            
            // Socket events - NOW INCLUDING ALL BIDDING EVENTS
            socket.on('soloGameCreated', (data) => {
                tableCode = data.tableCode;
            });
            
socket.on('gameStarted', (data) => {
    gameState = data.gameState || {};
    biddingState = data.biddingState || {};
    
    // √ÑL√Ñ aseta gameState.hands t√§√§ll√§! Kortit tulevat yourCards eventist√§
    
    gameState.gamePhase = 'bidding';
    updatGameUI();
    renderBiddingUI();

    resetPlayedCardsContainer();
    announceToScreenReader('Game started. Bidding phase begins.');
});

socket.on('dummyRevealed', (data) => {
    if (gameState && data.dummyCards && data.dummyPosition) {
        if (!gameState.hands) gameState.hands = {};
        gameState.hands[data.dummyPosition] = data.dummyCards;
        renderHand(data.dummyPosition, data.dummyCards);
        announceToScreenReader(`Dummy cards revealed: ${positionName(data.dummyPosition)}.`);
    }
});

socket.on('yourCards', (data) => {
    myPosition = data.position;
    if (!gameState) gameState = {};
    if (!gameState.hands) gameState.hands = {};
    
    // TURVALLINEN: Aseta vain oma k√§si
    gameState.hands[data.position] = data.cards;
    renderHand(data.position, data.cards);
});

            
            socket.on('bidMade', (data) => {
                biddingState = data.biddingState;
                renderBiddingUI();
                
                const bidText = data.bid === 'P' ? 'passes' : 
                              data.bid === 'X' ? 'doubles' : 
                              data.bid === 'XX' ? 'redoubles' : `bids ${formatBidForDisplay(data.bid)}`;
                announceToScreenReader(`${positionName(data.position)} ${bidText}.`);
            });
            
            socket.on('biddingComplete', (data) => {
                gameState.contract = data.contract;
                gameState.declarer = data.declarer;
                gameState.dummy = data.dummy;
                gameState.trumpSuit = data.trumpSuit;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gamePhase = 'play';
                
                if (biddingState) {
                    biddingState.biddingComplete = true;
                }
                
                document.getElementById('bidding-area').style.display = 'none';
                updateGameUI();
                
                // KORJATTU: Render√∂i kaikki k√§det uudelleen kun declarer/dummy status selvi√§√§
                renderAllHands();
                
                const contractMessage = `Final contract: ${formatContract(data.contract)} by ${positionName(data.declarer)}. ${positionName(data.currentPlayer)} leads.`;
                
                // LIS√ÑTTY: Ilmoita jos olemme declarer
                if (data.declarer === 'south') {
                    const dummyMessage = ` You are the declarer and control both South and North (dummy).`;
                    announceToScreenReader(contractMessage + dummyMessage);
                } else {
                    announceToScreenReader(contractMessage);
                }
            });
            
            socket.on('playPhaseCards', (data) => {
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                
                if (data.dummyCards) {
                    gameState.hands[gameState.dummy] = data.dummyCards;
                    announceToScreenReader(`Dummy's cards are now visible.`);
                }
                
                // KORJATTU: Render√∂i kaikki k√§det uudelleen
                renderAllHands();
            });
            
socket.on('cardPlayed', (data) => {
                if (!gameState.currentTrick) gameState.currentTrick = [];
                
                gameState.currentTrick = data.currentTrick;
                
                if (gameState.hands[data.position]) {
                    const suitCards = gameState.hands[data.position][data.suit];
                    if (suitCards) {
                        const index = suitCards.indexOf(data.card);
                        if (index > -1) {
                            suitCards.splice(index, 1);
                        }
                    }
                }
                
                renderHand(data.position, gameState.hands[data.position]);
                updatePlayedCard(data.position, data.suit, data.card);
                
                // LIS√ÑTTY: P√§ivit√§ current trick n√§ytt√∂
                updatePlayedCardsContainer();
                
                announceToScreenReader(`${positionName(data.position)} played ${suitName(data.suit)} ${data.card}`);
            });

            socket.on('trickComplete', (data) => {
                gameState.currentTrick = [];
                gameState.tricks = data.tricks;
                gameState.currentPlayer = data.nextPlayer;
                
                updateCenterArea();
                updateGameUI();
                                // LIS√ÑTTY: Tyhjenn√§ current trick n√§ytt√∂ kun tikki on valmis
                resetPlayedCardsContainer();
                
                const winner = positionName(data.winner);

                const next = positionName(data.nextPlayer);
                
                // KORJATTU: Check if next player is controlled by us (declarer controlling dummy)
                const isUserNext = (data.nextPlayer === 'south') || 
                                 (data.nextPlayer === 'north' && gameState.declarer === 'south' && gameState.dummy === 'north');
                
                let message;
                if (isUserNext) {
                    message = `${winner} won the trick. Your turn to play a card.`;
                } else {
                    message = `${winner} won the trick. ${next} plays next.`;
                }
                
                announceToScreenReader(message);
            });
            
            socket.on('nextPlayer', (data) => {
                gameState.currentPlayer = data.currentPlayer;
                updateGameUI();
                
                // KORJATTU: Re-render hands when current player changes to update button states
                renderAllHands();
                
                // Siirret√§√§n fokus automaattisesti pyydetyn maan korttiin kun tulee meid√§n vuoro
                autoFocusOnLeadSuit();
            });

            socket.on('gameOver', (data) => {
                gameState.gamePhase = 'end';
                gameState.tricks = data.tricks;
                
                showGameOver(data.message);
                announceToScreenReader(data.message);
            });
        });
    </script>
</body>
</html>