<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BridgeCircle - Play Solo</title>
    <link rel="stylesheet" href="css/main.css">
    <meta name="description" content="Play bridge against GIB AI opponents">
</head>
<body>
    <div class="container" id="game-view">
        <h1>BridgeCircle - Play Solo</h1>
        
        <!-- ARIA Live area for announcements -->
        <div id="status-announcer" aria-live="polite" class="sr-only"></div>
        
        <!-- Error message container -->
        <div id="error-area" class="error-message" style="display: none;"></div>
        
        <!-- Player management -->
        <section class="section">
            <h2>Players</h2>
            <div class="player-controls" id="players-area">
                <!-- Player information will be added here with JavaScript -->
            </div>
        </section>
        
        <!-- Status message -->
        <div class="status-bar" id="status-area" role="status">
            Welcome to BridgeCircle Solo Play
        </div>
        
        <!-- Action buttons -->
        <div class="action-buttons">
            <button onclick="toggleHelp()" id="toggle-help-button" class="button button-secondary" aria-expanded="false">
                Show Help
            </button>
            
            <button onclick="dealNewCards()" id="deal-button" class="button">
                Deal New Cards
            </button>
            
            <button onclick="navigate('/')" class="button button-secondary">
                Back to Lobby
            </button>
            
            <button onclick="fullscreen()" id="fullscreen-button" class="button button-secondary">
                Full Screen
            </button>
        </div>
        
        <!-- Help section (hidden initially) -->
        <section class="help-section" id="help-section" style="display: none;" role="dialog" aria-labelledby="help-title">
            <h2 id="help-title">Keyboard Shortcuts</h2>
            <ul class="help-list" id="help-list">
                <!-- Will be populated by JavaScript -->
            </ul>
            <button onclick="closeHelp()" id="close-help-button" class="button">
                Close Help
            </button>
        </section>
        
        <!-- Bidding area -->
        <section class="section" id="bidding-area" style="display: none;">
            <h2>Bidding Phase</h2>
            <div id="bidding-history" class="bidding-history">
                <h3>Bidding History</h3>
                <p>No bids yet.</p>
            </div>
            <div id="bidding-controls" class="bidding-controls">
                <h3>Your Bid</h3>
                <p>Waiting for bidding to start...</p>
            </div>
        </section>
        
        <!-- Game table -->
        <div class="game-table">
            <!-- North (top) -->
            <div class="hand north-hand" id="north-hand">
                <h3>North (GIB)</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
            
            <!-- East (right) -->
            <div class="hand east-hand" id="east-hand">
                <h3>East (GIB)</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- Center area -->
            <div class="center-area" id="center-area">
                <!-- Played cards and center information will be added here -->
                <p>Click "Deal New Cards" to start a game</p>
            </div>
            
            <!-- West (left) -->
            <div class="hand west-hand" id="west-hand">
                <h3>West (GIB)</h3>
                <p>Cards: ?</p>
            </div>
            
            <!-- South (bottom - player's hand) -->
            <div class="hand south-hand" id="south-hand">
                <h3>Your Hand (South)</h3>
                <!-- Card information will be added here with JavaScript -->
            </div>
        </div>
        
        <!-- Played cards -->
        <section class="section" id="played-cards-area">
            <h2>Played Cards</h2>
            <div id="played-cards-container">
                <p class="text-gray-500">No cards played yet.</p>
            </div>
        </section>
    </div>
    
    <!-- JavaScript files -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="js/bridge.js"></script>
    <script>
        let tableCode = null;
        let gameState = null;
        let biddingState = null;
        let myPosition = 'south'; // Always south in solo play
        
        // UI state for keyboard shortcuts
        const uiState = {
            showHelp: false,
            lastAnnouncement: '',
            bidLevel: null, // For bidding shortcuts
        };

        // DOM references
        const elements = {
            statusAnnouncer: document.getElementById('status-announcer'),
            helpSection: document.getElementById('help-section'),
            helpList: document.getElementById('help-list'),
            toggleHelpButton: document.getElementById('toggle-help-button'),
            closeHelpButton: document.getElementById('close-help-button'),
            dealButton: document.getElementById('deal-button'),
            biddingArea: document.getElementById('bidding-area'),
            biddingHistory: document.getElementById('bidding-history'),
            biddingControls: document.getElementById('bidding-controls'),
            northHand: document.getElementById('north-hand'),
            eastHand: document.getElementById('east-hand'),
            westHand: document.getElementById('west-hand'),
            southHand: document.getElementById('south-hand'),
            centerArea: document.getElementById('center-area'),
            playedCardsContainer: document.getElementById('played-cards-container')
        };

        // YKSINKERTAINEN ILMOITUSTEN JONOSYSTEEMI
        const announcementQueue = {
            queue: [],
            processing: false,
            currentTimeout: null,

            /**
             * Lisää ilmoitus jonoon
             */
            add(message) {
                // Tallenna viimeinen ilmoitus toistoa varten
                uiState.lastAnnouncement = message;
                
                // Lisää jonoon
                this.queue.push({
                    message: message,
                    timestamp: Date.now(),
                    estimatedDuration: this.estimateDuration(message)
                });

                // Aloita prosessointi jos ei ole käynnissä
                if (!this.processing) {
                    this.processNext();
                }
            },

            /**
             * Arvioi kuinka kauan viestin lukeminen kestää
             */
            estimateDuration(message) {
                // Keskimääräinen lukemisnopeus: ~150ms per merkki
                // Minimaika: 2 sekuntia, maksimaika: 10 sekuntia
                const baseRate = 150;
                const minDuration = 2000;
                const maxDuration = 2000;

                let estimated = message.length * baseRate;
                
                // Lisää aikaa välimerkeille (tauko)
                const punctuationCount = (message.match(/[.!?;,]/g) || []).length;
                estimated += punctuationCount * 400;

                return Math.max(minDuration, Math.min(maxDuration, estimated));
            },

            /**
             * Käsittele seuraava ilmoitus jonossa
             */
            processNext() {
                if (this.queue.length === 0) {
                    this.processing = false;
                    return;
                }

                this.processing = true;
                const announcement = this.queue.shift();

                // Tyhjennä ensin
                elements.statusAnnouncer.textContent = '';

                // Pieni viive, sitten ilmoita
                setTimeout(() => {
                    elements.statusAnnouncer.textContent = announcement.message;

                    // Aseta timeout seuraavalle ilmoitukselle
                    this.currentTimeout = setTimeout(() => {
                        this.processNext();
                    }, announcement.estimatedDuration);
                }, 100);
            },

            /**
             * Tyhjennä koko jono
             */
            clear() {
                this.queue = [];
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                elements.statusAnnouncer.textContent = '';
                this.processing = false;
            },

            /**
             * Toista viimeinen ilmoitus välittömästi (tyhjentää jonon)
             */
            repeatLast() {
                if (uiState.lastAnnouncement) {
                    this.clear();
                    this.add(uiState.lastAnnouncement);
                }
            }
        };

        /**
         * Pää-ilmoitusfunktio - käyttää jonosysteemiä
         */
        function announceToScreenReader(message) {
            announcementQueue.add(message);
        }

        // Keyboard shortcuts configuration
        const keyboardShortcuts = [
            // Card viewing shortcuts (Own cards)
            { key: 'a', alt: true, description: 'Read your spades', action: () => announceHandSuit('south', 'spades') },
            { key: 's', alt: true, description: 'Read your hearts', action: () => announceHandSuit('south', 'hearts') },
            { key: 'd', alt: true, description: 'Read your diamonds', action: () => announceHandSuit('south', 'diamonds') },
            { key: 'f', alt: true, description: 'Read your clubs', action: () => announceHandSuit('south', 'clubs') },
            { key: 'g', alt: true, description: 'Read all your cards', action: () => announceEntireHand('south') },
            
            // Card viewing shortcuts (Dummy's cards)
            { key: 'q', alt: true, description: 'Read dummy spades', action: () => announceHandSuit('north', 'spades') },
            { key: 'w', alt: true, description: 'Read dummy hearts', action: () => announceHandSuit('north', 'hearts') },
            { key: 'e', alt: true, description: 'Read dummy diamonds', action: () => announceHandSuit('north', 'diamonds') },
            { key: 'r', alt: true, description: 'Read dummy clubs', action: () => announceHandSuit('north', 'clubs') },
            { key: 't', alt: true, description: 'Read all dummy cards', action: () => announceEntireHand('north') },
            
            // Game state shortcuts
            { key: 'z', alt: true, description: 'Read current trick', action: () => announceCurrentTrick() },
            { key: 'x', alt: true, description: 'Read game state', action: () => announceGameState() },
            { key: 'c', alt: true, description: 'Announce current player', action: () => announceCurrentPlayer() },
            { key: 'v', alt: true, description: 'Read last played trick', action: () => announceLastTrick() },
            
            // Bidding shortcuts
            { key: 'p', alt: true, description: 'Bid Pass', action: () => makeBidShortcut('P') },
            { key: 'd', alt: true, description: 'Bid Double', action: () => makeBidShortcut('X') },
            { key: 'f', alt: true, description: 'Bid Redouble', action: () => makeBidShortcut('XX') },
            
            // Card playing shortcuts - high cards only
            { key: '1', ctrl: true, description: 'Play highest spade', action: () => playHighestCard('spades') },
            { key: '2', ctrl: true, description: 'Play highest heart', action: () => playHighestCard('hearts') },
            { key: '3', ctrl: true, description: 'Play highest diamond', action: () => playHighestCard('diamonds') },
            { key: '4', ctrl: true, description: 'Play highest club', action: () => playHighestCard('clubs') },
            
            // Direct suit keys - dual purpose in bidding and play
            { key: 's', description: 'Bidding: Spades | Play: Focus lowest spade', action: null }, // Handled separately
            { key: 'h', description: 'Bidding: Hearts | Play: Focus lowest heart', action: null }, // Handled separately
            { key: 'd', description: 'Bidding: Diamonds | Play: Focus lowest diamond', action: null }, // Handled separately
            { key: 'c', description: 'Bidding: Clubs | Play: Focus lowest club', action: null }, // Handled separately
            { key: 'n', description: 'Bidding: No Trump', action: null }, // Handled separately
            
            // General shortcuts
            { key: 'h', alt: true, description: 'Show/hide help', action: () => toggleHelp() },
            { key: 'n', alt: true, description: 'Deal new cards', action: () => dealNewCards() },
            { key: 'i', alt: true, description: 'Repeat last announcement', action: () => repeatLastAnnouncement() },
            { key: 'o', alt: true, description: 'Announce score', action: () => announceScore() },
            { key: 'm', alt: true, description: 'Restart game', action: () => restartGame() },
        ];

        // Simple number keys for bidding levels
        const bidLevelKeys = ['1', '2', '3', '4', '5', '6', '7'];
        // Simple suit keys for bidding
        const bidSuitKeys = {
            's': 'S', // Spades
            'h': 'H', // Hearts
            'd': 'D', // Diamonds
            'c': 'C', // Clubs
            'n': 'N'  // No Trump
        };

        /**
         * Tyhjennä ilmoitusjono
         */
        function clearAnnouncementQueue() {
            announcementQueue.clear();
            announceToScreenReader("Announcement queue cleared.");
        }

        /**
         * Toista viimeinen ilmoitus
         */
        function repeatLastAnnouncement() {
            if (uiState.lastAnnouncement) {
                announcementQueue.repeatLast();
            } else {
                announceToScreenReader("No announcement to repeat.");
            }
        }

        /**
         * Renders the help list
         */
        function renderHelpList() {
            elements.helpList.innerHTML = '';
            
            keyboardShortcuts.forEach(shortcut => {
                // Skip shortcuts with no action (they're handled separately)
                if (!shortcut.action) return;
                
                const modifiers = [];
                if (shortcut.alt) modifiers.push('Alt');
                if (shortcut.shift) modifiers.push('Shift');
                if (shortcut.ctrl) modifiers.push('Ctrl');
                
                const keyCombo = modifiers.length > 0 
                    ? `${modifiers.join('+')} + ${shortcut.key.toUpperCase()}`
                    : shortcut.key.toUpperCase();
                    
                const li = document.createElement('li');
                li.innerHTML = `<strong>${keyCombo}</strong>: ${shortcut.description}`;
                elements.helpList.appendChild(li);
            });
            
            // Add the dual-purpose keys
            const gamePhase = gameState ? gameState.gamePhase : 'setup';
            const phaseText = gamePhase === 'bidding' ? 'Select suit for bidding' : 
                             gamePhase === 'play' ? 'Focus on lowest card of suit' : 
                             'Depends on game phase';
            
            const dualPurposeKeys = [
                { key: 'S', desc: 'Spades' },
                { key: 'H', desc: 'Hearts' },
                { key: 'D', desc: 'Diamonds' },
                { key: 'C', desc: 'Clubs' }
            ];
            
            dualPurposeKeys.forEach(key => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${key.key}</strong>: ${phaseText} (${key.desc})`;
                elements.helpList.appendChild(li);
            });
            
            // Add the No Trump key for bidding
            if (gamePhase === 'bidding') {
                const li = document.createElement('li');
                li.innerHTML = `<strong>N</strong>: Select No Trump for bidding`;
                elements.helpList.appendChild(li);
            }
        }

        /**
         * Announces cards in a specific suit from a hand and focuses on the lowest card
         */
        function announceHandSuit(position, suit) {
            // Check if we can view these cards
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            const canViewCards = position === 'south' || 
                                (position === 'north' && gameState && gameState.gamePhase === 'play' && isNSTeamWon);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                const message = `${getPositionName(position)} has no ${getSuitName(suit)}s.`;
                announceToScreenReader(message);
                return;
            }
            
            const message = `${getPositionName(position)}'s ${getSuitName(suit)}s: ${cards.join(', ')}`;
            announceToScreenReader(message);
            
            const isCurrentPlayer = position === (gameState ? gameState.currentPlayer : null);
            const isPlayable = gameState && gameState.gamePhase === 'play' && isCurrentPlayer;
}

        /**
         * Focuses on the lowest card of a specific suit
         */
        function focusLowestCardOfSuit(position, suit) {
            // Check if the current player can play cards
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            const isPlayersTurn = gameState && (gameState.currentPlayer === position) && 
                                 (position === 'south' || 
                                  (position === 'north' && isNSTeamWon));
            
            if (!isPlayersTurn || !gameState || gameState.gamePhase !== 'play') {
                return; // Don't focus if not player's turn or not in play phase
            }
            
            // Get the cards of the suit
            const hand = gameState.hands[position];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                return; // No cards of this suit
            }
            
            // Check if the player must follow suit
            let canPlayThisSuit = true;
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    canPlayThisSuit = false; // Must follow lead suit
                }
            }
            
            if (!canPlayThisSuit) {
                // Announce that player must follow lead suit
                const leadSuit = gameState.currentTrick[0].suit;
                announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                return;
            }
            
            // Find the lowest card button for this suit
            const values = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => values.indexOf(a) - values.indexOf(b));
            const lowestCard = sortedCards[0];
            
            // Get the hand element
            const handElement = position === 'south' ? elements.southHand : elements.northHand;
            
            // Find the button for this card
            const cardButton = handElement.querySelector(`button[data-suit="${suit}"][data-card="${lowestCard}"]`);
            
            if (cardButton) {
                // Focus the button
                cardButton.focus();
                
                // Announce that focus has moved
                announceToScreenReader(`Focused on ${getSuitName(suit)} ${lowestCard}.`);
            }
        }

/**
 * Siirtää automaattisesti fokuksen pakollisen maan pienimpään korttiin
 */
function autoFocusOnRequiredSuit(position) {
    if (!gameState || gameState.gamePhase !== 'play') return;
    
    const hand = gameState.hands[position];
    if (!hand) return;
    
    // Jos trick on tyhjä, ei siirretä fokusta (pelaaja voi aloittaa millä tahansa)
    if (!gameState.currentTrick || gameState.currentTrick.length === 0) {
        return;
    }
    
    // Selvitetään pakollinen maa
    const leadSuit = gameState.currentTrick[0].suit;
    
    // Jos pelaajalla on lead suitin kortteja, siirretään fokus sinne
    if (hand[leadSuit] && hand[leadSuit].length > 0) {
        focusLowestCardOfSuit(position, leadSuit);
    }
    // Jos ei ole lead suitin kortteja, pelaaja voi pelata mitä tahansa - ei siirretä fokusta
}

        /**
         * Announces all cards in a hand
         */
        function announceEntireHand(position) {
            // Check if we can view these cards
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            const canViewCards = position === 'south' || 
                                (position === 'north' && gameState && gameState.gamePhase === 'play' && isNSTeamWon);
            
            if (!canViewCards) {
                const message = `Cannot view ${getPositionName(position)}'s cards at this time.`;
                announceToScreenReader(message);
                return;
            }
            
            const hand = gameState && gameState.hands ? gameState.hands[position] : null;
            if (!hand) {
                announceToScreenReader(`No cards available for ${getPositionName(position)}.`);
                return;
            }
            
            let message = `${getPositionName(position)}'s hand: `;
            
            for (const suit of ['spades', 'hearts', 'diamonds', 'clubs']) {
                const cards = hand[suit] || [];
                if (cards.length > 0) {
                    message += `${getSuitName(suit)}s: ${cards.join(', ')}. `;
                } else {
                    message += `No ${getSuitName(suit)}s. `;
                }
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the current trick
         */
        function announceCurrentTrick() {
            if (!gameState || gameState.gamePhase !== 'play') {
                announceToScreenReader('The game is not in play phase yet.');
                return;
            }
            
            if (!gameState.currentTrick || gameState.currentTrick.length === 0) {
                announceToScreenReader('No cards played in the current trick yet.');
                return;
            }
            
            let message = 'Current trick: ';
            
            for (const card of gameState.currentTrick) {
                message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the game state
         */
        function announceGameState() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            let message = `Game phase: ${gameState.gamePhase}. `;
            
            if (gameState.gamePhase === 'play' || gameState.gamePhase === 'end') {
                message += `Contract: ${formatContract(gameState.contract)} by ${getPositionName(gameState.declarer)}. `;
                message += `North-South tricks: ${gameState.tricks.ns}. East-West tricks: ${gameState.tricks.ew}. `;
                message += `Current player: ${getPositionName(gameState.currentPlayer)}.`;
            } else if (gameState.gamePhase === 'bidding') {
                message += `Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`;
            }
            
            announceToScreenReader(message);
        }

        /**
         * Announces the current player
         */
        function announceCurrentPlayer() {
            if (!gameState) {
                announceToScreenReader('No game in progress.');
                return;
            }
            
            if (gameState.gamePhase === 'play') {
                announceToScreenReader(`Current player: ${getPositionName(gameState.currentPlayer)}.`);
            } else if (gameState.gamePhase === 'bidding') {
                announceToScreenReader(`Current bidder: ${getPositionName(biddingState ? biddingState.currentBidder : 'unknown')}.`);
            } else {
                announceToScreenReader(`Game phase: ${gameState.gamePhase}. No current player.`);
            }
        }

        /**
         * Announces the last completed trick
         */
        function announceLastTrick() {
            if (!gameState || !gameState.playedCards || gameState.playedCards.length === 0) {
                announceToScreenReader('No tricks have been played yet.');
                return;
            }
            
            // Find the last 4 cards that don't belong to the current trick
            const currentTrickIds = gameState.currentTrick ? gameState.currentTrick.map(card => `${card.player}:${card.suit}:${card.card}`) : [];
            const pastCards = gameState.playedCards.filter(card => 
                !currentTrickIds.includes(`${card.player}:${card.suit}:${card.card}`)
            );
            
            if (pastCards.length === 0) {
                announceToScreenReader('No previous tricks to announce.');
                return;
            }
            
            // Get the last complete trick (4 cards)
            const startIndex = Math.max(0, pastCards.length - (pastCards.length % 4 === 0 ? 4 : pastCards.length % 4));
            const lastTrick = pastCards.slice(startIndex);
            
            let message = 'Last played trick: ';
            
            for (const card of lastTrick) {
                message += `${getPositionName(card.player)} played ${getSuitName(card.suit)} ${card.card}. `;
            }
            
            announceToScreenReader(message);
        }

        /**
         * Makes a bid using keyboard shortcut
         */
        function makeBidShortcut(bid) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south') {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            // For regular bids, we need both level and suit
            if (!['P', 'X', 'XX'].includes(bid)) {
                announceToScreenReader('Invalid bid format.');
                return;
            }
            
            makeBid(bid);
        }

        /**
         * Handles bid level selection for two-step bidding
         */
        function handleBidLevelKey(level) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south') {
                announceToScreenReader("It's not your turn to bid.");
                return;
            }
            
            uiState.bidLevel = level;
            announceToScreenReader(`Bid level ${level} selected. Press S, H, D, C, or N to select suit.`);
        }

        /**
         * Handles bid suit selection to complete a bid
         */
        function handleBidSuitKey(suit) {
            if (!gameState || gameState.gamePhase !== 'bidding' || !biddingState || biddingState.currentBidder !== 'south' || !uiState.bidLevel) {
                if (!uiState.bidLevel) {
                    announceToScreenReader("Please select a bid level 1 through 7 first.");
                } else {
                    announceToScreenReader("It's not your turn to bid.");
                }
                return;
            }
            
            const bid = `${uiState.bidLevel}${suit}`;
            
            // Check if bid is valid
            if (!isValidBid(bid, biddingState.highestBid)) {
                announceToScreenReader(`Invalid bid: ${uiState.bidLevel} ${getSuitNameForBid(suit)}.`);
                uiState.bidLevel = null; // Reset bid level
                return;
            }
            
            makeBid(bid);
            uiState.bidLevel = null; // Reset bid level
        }

        /**
         * Check if bid is valid
         */
        function isValidBid(bid, highestBid) {
            // Pass is always valid
            if (bid === 'P') return true;
            
            // Double and Redouble
            if (bid === 'X' || bid === 'XX') return true;
            
            // Regular bid - must be higher than current highest
            if (!highestBid) return true; // First bid is always valid
            
            const bidLevel = parseInt(bid.charAt(0));
            const bidSuit = bid.charAt(1);
            const highestLevel = parseInt(highestBid.charAt(0));
            const highestSuit = highestBid.charAt(1);
            
            const suits = ['C', 'D', 'H', 'S', 'N'];
            const bidSuitIndex = suits.indexOf(bidSuit);
            const highestSuitIndex = suits.indexOf(highestSuit);
            
            if (bidLevel > highestLevel) return true;
            if (bidLevel === highestLevel && bidSuitIndex > highestSuitIndex) return true;
            
            return false;
        }

        /**
         * Gets a suit name for bid announcement
         */
        function getSuitNameForBid(suit) {
            switch(suit) {
                case 'C': return 'Clubs';
                case 'D': return 'Diamonds';
                case 'H': return 'Hearts';
                case 'S': return 'Spades';
                case 'N': return 'No Trump';
                default: return suit;
            }
        }

        /**
         * Handles suit key press during play phase
         */
        function handleSuitKeyInPlayPhase(suitKey) {
            // Map key to suit
            const suitMap = {
                's': 'spades',
                'h': 'hearts',
                'd': 'diamonds',
                'c': 'clubs'
            };
            
            const suit = suitMap[suitKey];
            if (!suit) return;
            
            // Determine current player
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            const isCurrentPlayerHuman = gameState && ((gameState.currentPlayer === 'south') || 
                                       (isNSTeamWon && gameState.currentPlayer === 'north'));
            
            if (!isCurrentPlayerHuman) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            // Get current player's hand
            const hand = gameState.hands[gameState.currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s.`);
                return;
            }
            
            // Check if player must follow suit
            let canPlayThisSuit = true;
            let warningMessage = '';
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    // Notify player but still focus on the card
                    warningMessage = `Reminder: You must follow the lead suit ${getSuitName(leadSuit)}. `;
                    canPlayThisSuit = false;
                }
            }
            
            // Focus on the lowest card
            const values = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => values.indexOf(a) - values.indexOf(b));
            const lowestCard = sortedCards[0];
            
            // Get the hand element for the current player
            const handElement = gameState.currentPlayer === 'south' ? elements.southHand : elements.northHand;
            
            // Find the button for this card
            const cardButton = handElement.querySelector(`button[data-suit="${suit}"][data-card="${lowestCard}"]`);
            
            if (cardButton) {
                // Focus the button
                cardButton.focus();
                
                // Announce
                const message = warningMessage + `Focused on ${getSuitName(suit)} ${lowestCard}.`;
                announceToScreenReader(message);
            } else {
                announceToScreenReader(`Could not find playable ${getSuitName(suit)} card.`);
            }
        }

        /**
         * Plays the highest card of a suit
         */
        function playHighestCard(suit) {
            // Determine which player is active
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            const isCurrentPlayerHuman = gameState && ((gameState.currentPlayer === 'south') || 
                                       (isNSTeamWon && gameState.currentPlayer === 'north'));
            
            if (!gameState || gameState.gamePhase !== 'play' || !isCurrentPlayerHuman) {
                announceToScreenReader("It's not your turn to play.");
                return;
            }
            
            const hand = gameState.hands[gameState.currentPlayer];
            const cards = hand[suit] || [];
            
            if (cards.length === 0) {
                announceToScreenReader(`You have no ${getSuitName(suit)}s to play.`);
                return;
            }
            
            // Check if player must follow suit
            if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                const leadSuit = gameState.currentTrick[0].suit;
                if (suit !== leadSuit && hand[leadSuit] && hand[leadSuit].length > 0) {
                    announceToScreenReader(`You must follow the lead suit: ${getSuitName(leadSuit)}.`);
                    return;
                }
            }
            
            // Get the highest card (we need to convert card ranks for comparison)
            const values = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
            const sortedCards = [...cards].sort((a, b) => values.indexOf(b) - values.indexOf(a));
            const highestCard = sortedCards[0];
            
            // Play the card
            playCard(suit, highestCard);
        }

        /**
         * Announces the current score
         */
        function announceScore() {
            if (gameState && (gameState.gamePhase === 'play' || gameState.gamePhase === 'end')) {
                announceToScreenReader(`North-South: ${gameState.tricks.ns} tricks. East-West: ${gameState.tricks.ew} tricks.`);
            } else {
                announceToScreenReader("No score available yet.");
            }
        }

        /**
         * Restarts the game
         */
        function restartGame() {
            if (confirm("Are you sure you want to restart the game?")) {
                dealNewCards();
                announceToScreenReader('Game restarted. New cards dealt.');
            }
        }

        /**
         * Helper functions for naming
         */
        function getPositionName(position) {
            switch(position) {
                case 'north': return 'North';
                case 'east': return 'East';
                case 'south': return 'South';
                case 'west': return 'West';
                default: return position || 'Unknown';
            }
        }

        function getSuitName(suit) {
            const names = {
                spades: 'Spades',
                hearts: 'Hearts',
                diamonds: 'Diamonds',
                clubs: 'Clubs'
            };
            return names[suit] || suit;
        }

        function getSuitSymbol(suit) {
            const symbols = { 
                spades: '♠', 
                hearts: '♥', 
                diamonds: '♦', 
                clubs: '♣' 
            };
            return symbols[suit] || suit;
        }

        // Show help
        function showHelp() {
            uiState.showHelp = true;
            toggleHelp();
        }
        
        // Close help
        function closeHelp() {
            uiState.showHelp = false;
            toggleHelp();
        }

        /**
         * Show/hide help section
         */
        function toggleHelp() {
            uiState.showHelp = !uiState.showHelp;
            elements.helpSection.style.display = uiState.showHelp ? 'block' : 'none';
            elements.toggleHelpButton.textContent = uiState.showHelp ? 'Hide Help' : 'Show Help';
            elements.toggleHelpButton.setAttribute('aria-expanded', uiState.showHelp);
            
            if (uiState.showHelp) {
                renderHelpList();
            }
        }
        
        // Deal new cards
        function dealNewCards() {
            // Clear previous game state
            gameState = null;
            biddingState = null;
            
            // Clear announcement queue to avoid confusion
            announcementQueue.clear();
            
            // Hide bidding area
            document.getElementById('bidding-area').style.display = 'none';
            
            // If table code exists, reset the game
            if (tableCode) {
                socket.emit('resetSoloGame', {
                    tableCode: tableCode
                });
            } else {
                // Otherwise initialize a new solo game
                initializeSoloGame();
            }
            
            // Announce new deal
            announceToScreenReader('Dealing new cards...');
        }
        
        // Fullscreen mode
        function fullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error entering fullscreen mode: ${err.message}`);
                });
                document.getElementById('fullscreen-button').textContent = 'Exit Fullscreen';
            } else {
                document.exitFullscreen();
                document.getElementById('fullscreen-button').textContent = 'Full Screen';
            }
        }
        
        // Initialize solo game
        function initializeSoloGame() {
            // Get player name from localStorage or use default
            const playerName = localStorage.getItem('playerName') || 'Player';
            
            // Send request to server
            socket.emit('createSoloGame', {
                playerName: playerName
            });
        }
        
        // Render hand (same as original)
        function renderHand(position, hand, isPlayable = false) {
            const element = position === 'north' ? document.getElementById('north-hand') :
                           position === 'south' ? document.getElementById('south-hand') :
                           position === 'east' ? document.getElementById('east-hand') :
                           document.getElementById('west-hand');
            
            if (!element || !hand) return;
            
            const isCurrentPlayer = gameState && gameState.currentPlayer === position;
            const isNSTeamWon = gameState && (gameState.declarer === 'south' || gameState.declarer === 'north');
            
            const isPlayableByHuman = position === 'south' || 
                                   (position === 'north' && isNSTeamWon && 
                                    gameState.players && gameState.players[position].type === 'human');
            
            let html = `<h3>${position === 'south' ? 'Your Hand (South)' : positionName(position)} 
                      ${gameState && gameState.players && gameState.players[position].type === 'gib' ? '(GIB)' : ''}</h3>`;
            
            const showCards = position === 'south' || 
                           (position === 'north' && 
                            (gameState && gameState.gamePhase === 'play' && isNSTeamWon));
            
            if (!showCards && position === 'north') {
                html += `<p>Cards will be visible when play begins, if South or North is declarer.</p>`;
                element.innerHTML = html;
                return;
            }
            
            Object.entries(hand).forEach(([suit, cards]) => {
                const suitClass = `suit-${suit}`;
                
                html += `
                    <div class="suit-row">
                        <div class="suit-label ${suitClass}">
                            ${suitSymbol(suit)} ${suitName(suit)}
                        </div>
                        <div class="cards-buttons">
                `;
                
                if (cards.length > 0) {
                    cards.forEach(card => {
                        const cardClass = `card-${suit}`;
                        
                        if (gameState && gameState.gamePhase === 'play' && isPlayableByHuman) {
                            html += `
                                <button 
                                    class="card-button ${cardClass}"
                                    data-suit="${suit}"
                                    data-card="${card}"
                                    onclick="playCard('${suit}', '${card}')"
                                    ${!isCurrentPlayer ? 'disabled' : ''}
                                    aria-label="Play ${suitName(suit)} ${card}"
                                >
                                    ${card}
                                </button>
                            `;
                        } else {
                            html += `
                                <span class="card-display ${cardClass}" aria-label="${suitName(suit)} ${card}">
                                    ${card}
                                </span>
                            `;
                        }
                    });
                } else {
                    html += `<span class="text-gray-400">(empty)</span>`;
                }
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            element.innerHTML = html;
        }
        
        // Play card
        function playCard(suit, card) {
            if (!tableCode) return;
            
            socket.emit('playCard', {
                tableCode: tableCode,
                position: myPosition,
                suit: suit,
                card: card
            });
        }
        
        // Render bidding UI
        function renderBiddingUI() {
            const biddingArea = document.getElementById('bidding-area');
            if (biddingArea) {
                biddingArea.style.display = 'block';
            }
            
            renderBiddingHistory();
            
            if (biddingState && biddingState.currentBidder === myPosition) {
                renderBiddingControls();
            } else {
                const biddingControls = document.getElementById('bidding-controls');
                if (biddingControls) {
                    biddingControls.innerHTML = `
                        <h3>Your Bid</h3>
                        <p>Waiting for ${positionName(biddingState ? biddingState.currentBidder : 'unknown')} to bid...</p>
                    `;
                }
            }
        }
        
        // Render bidding history
        function renderBiddingHistory() {
            const biddingHistory = document.getElementById('bidding-history');
            if (!biddingHistory) return;
            
            let html = '<h3>Bidding History</h3>';
            
            if (!biddingState || !biddingState.bidHistory || biddingState.bidHistory.length === 0) {
                html += '<p>No bids yet.</p>';
            } else {
                html += `
                    <table class="bidding-table">
                        <thead>
                            <tr>
                                <th>West</th>
                                <th>North</th>
                                <th>East</th>
                                <th>South</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                const rounds = [];
                let currentRound = [];
                let dealerIndex = ['west', 'north', 'east', 'south'].indexOf(biddingState.dealer);
                
                for (let i = 0; i < dealerIndex; i++) {
                    currentRound.push(null);
                }
                
                for (const bid of biddingState.bidHistory) {
                    currentRound.push(bid);
                    
                    if (currentRound.length === 4) {
                        rounds.push([...currentRound]);
                        currentRound = [];
                    }
                }
                
                if (currentRound.length > 0) {
                    rounds.push([...currentRound]);
                }
                
                for (const round of rounds) {
                    html += '<tr>';
                    
                    for (let i = 0; i < 4; i++) {
                        const bid = round[i];
                        
                        if (!bid) {
                            html += '<td></td>';
                        } else {
                            const bidText = formatBidForDisplay(bid.bid);
                            html += `<td>${bidText}</td>`;
                        }
                    }
                    
                    html += '</tr>';
                }
                
                html += '</tbody></table>';
            }
            
            biddingHistory.innerHTML = html;
        }
        
        // Render bidding controls
        function renderBiddingControls() {
            const biddingControls = document.getElementById('bidding-controls');
            if (!biddingControls) return;
            
            const possibleBids = getPossibleBids(biddingState ? biddingState.highestBid : null);
            
            let html = '<h3>Your Bid</h3>';
            html += '<div class="bidding-buttons">';
            
            for (const specialBid of ['P', 'X', 'XX']) {
                if (possibleBids.includes(specialBid)) {
                    const bidText = specialBid === 'P' ? 'Pass' : 
                                  specialBid === 'X' ? 'Double (X)' : 'Redouble (XX)';
                    
                    html += `
                        <button class="bid-button" onclick="makeBid('${specialBid}')">
                            ${bidText}
                        </button>
                    `;
                }
            }
            
            const contractBids = possibleBids.filter(bid => !['P', 'X', 'XX'].includes(bid));
            const bidsByLevel = {};
            
            for (const bid of contractBids) {
                const level = bid.charAt(0);
                if (!bidsByLevel[level]) bidsByLevel[level] = [];
                bidsByLevel[level].push(bid);
            }
            
            for (const level in bidsByLevel) {
                html += `<div class="bid-level-group">`;
                
                for (const bid of bidsByLevel[level]) {
                    const suit = bid.charAt(1);
                    let suitSymbol, suitClass;
                    
                    switch(suit) {
                        case 'C': 
                            suitSymbol = '♣'; 
                            suitClass = 'bid-clubs';
                            break;
                        case 'D': 
                            suitSymbol = '♦'; 
                            suitClass = 'bid-diamonds';
                            break;
                        case 'H': 
                            suitSymbol = '♥'; 
                            suitClass = 'bid-hearts';
                            break;
                        case 'S': 
                            suitSymbol = '♠'; 
                            suitClass = 'bid-spades';
                            break;
                        case 'N': 
                            suitSymbol = 'NT'; 
                            suitClass = 'bid-notrump';
                            break;
                        default: 
                            suitSymbol = suit;
                            suitClass = '';
                    }
                    
                    html += `
                        <button class="bid-button ${suitClass}" onclick="makeBid('${bid}')">
                            ${level}${suitSymbol}
                        </button>
                    `;
                }
                
                html += `</div>`;
            }
            
            html += '</div>';
            html += '<div class="bid-meanings">';
            html += `<p><strong>System:</strong> Natural</p>`;
            html += '</div>';
            
            biddingControls.innerHTML = html;
        }
        
        // Make bid
        function makeBid(bid) {
            if (!tableCode) return;
            
            socket.emit('makeBid', {
                tableCode: tableCode,
                position: myPosition,
                bid: bid
            });
        }
        
        // Get possible bids
        function getPossibleBids(highestBid) {
            const possibleBids = ['P'];
            
            if (highestBid) {
                possibleBids.push('X');
            }
            
            const levels = ['1', '2', '3', '4', '5', '6', '7'];
            const suits = ['C', 'D', 'H', 'S', 'N'];
            
            if (!highestBid) {
                for (const level of levels) {
                    for (const suit of suits) {
                        possibleBids.push(`${level}${suit}`);
                    }
                }
            } else {
                const highestLevel = parseInt(highestBid.charAt(0));
                const highestSuit = highestBid.charAt(1);
                const highestSuitIndex = suits.indexOf(highestSuit);
                
                for (let level = highestLevel; level <= 7; level++) {
                    for (let suitIndex = 0; suitIndex < suits.length; suitIndex++) {
                        if (level === highestLevel && suitIndex <= highestSuitIndex) continue;
                        possibleBids.push(`${level}${suits[suitIndex]}`);
                    }
                }
            }
            
            return possibleBids;
        }
        
        // Format bid for display
        function formatBidForDisplay(bid) {
            if (bid === 'P') return 'Pass';
            if (bid === 'X') return 'X (Double)';
            if (bid === 'XX') return 'XX (Redouble)';
            
            const level = bid.charAt(0);
            const suit = bid.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            return `${level}${suitSymbol}`;
        }
        
        // Update game UI
        function updateGameUI() {
            if (!gameState) return;
            
            const playersArea = document.getElementById('players-area');
            if (playersArea) {
                let html = '';
                
                const positions = ['north', 'east', 'south', 'west'];
                for (const position of positions) {
                    const isCurrentPlayer = gameState.currentPlayer === position;
                    const player = gameState.players[position];
                    const playerName = player ? player.name : positionName(position);
                    const playerType = player ? player.type : 'human';
                    
                    html += `
                        <div class="player-badge ${isCurrentPlayer ? 'current' : ''}">
                            <div>${positionName(position)}</div>
                            <div>${playerName}</div>
                            <div>${playerType === 'gib' ? 'GIB' : 'Human'}</div>
                        </div>
                    `;
                }
                
                playersArea.innerHTML = html;
            }
            
            const statusArea = document.getElementById('status-area');
            if (statusArea) {
                if (gameState.gamePhase === 'bidding') {
                    statusArea.textContent = 'Bidding phase';
                } else if (gameState.gamePhase === 'play') {
                    statusArea.textContent = `Playing: ${formatContract(gameState.contract)}`;
                } else {
                    statusArea.textContent = 'BridgeCircle Solo Play';
                }
            }
        }
        
        // Format contract
        function formatContract(contract) {
            if (!contract) return "No contract";
            
            const level = contract.charAt(0);
            const suit = contract.charAt(1);
            let suitSymbol;
            
            switch(suit) {
                case 'C': suitSymbol = '♣'; break;
                case 'D': suitSymbol = '♦'; break;
                case 'H': suitSymbol = '♥'; break;
                case 'S': suitSymbol = '♠'; break;
                case 'N': suitSymbol = 'NT'; break;
                default: suitSymbol = suit;
            }
            
            let result = `${level}${suitSymbol}`;
            
            if (contract.includes('XX')) {
                result += ' XX';
            } else if (contract.includes('X')) {
                result += ' X';
            }
            
            return result;
        }
        
        // Update center area
        function updateCenterArea() {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.gamePhase === 'play') {
                let html = '<h3>Played Tricks</h3>';
                
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
                
                if (gameState.contract) {
                    html += `<p>Contract: ${formatContract(gameState.contract)}, `;
                    html += `declarer: ${positionName(gameState.declarer)}</p>`;
                }
                
                centerArea.innerHTML = html;
            }
        }
        
        // Update played card
        function updatePlayedCard(position, suit, card) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            if (gameState && gameState.currentTrick && gameState.currentTrick.length === 1) {
                centerArea.innerHTML = '<h3>Current Trick</h3>';
            }
            
            const cardElement = document.createElement('div');
            cardElement.className = `played-card ${suit === 'hearts' || suit === 'diamonds' ? 'red-card' : ''}`;
            cardElement.innerHTML = `<span class="player-name">${positionName(position)}:</span> ${suitSymbol(suit)} ${card}`;
            
            centerArea.appendChild(cardElement);
        }
        
        // Show game over
        function showGameOver(message) {
            const centerArea = document.getElementById('center-area');
            if (!centerArea) return;
            
            let html = '<h3>Game Over</h3>';
            html += `<p>${message}</p>`;
            
            if (gameState && gameState.tricks) {
                html += `<p>NS: ${gameState.tricks.ns}, EW: ${gameState.tricks.ew}</p>`;
            }
            
            html += `<button onclick="dealNewCards()" class="button">Deal New Cards</button>`;
            
            centerArea.innerHTML = html;
        }
        
        // Make move (bid or play card)
        function makeMove() {
            if (!gameState) return;
            
            if (gameState.gamePhase === 'bidding' && biddingState && biddingState.currentBidder === myPosition) {
                makeBid('P');
            } else if (gameState.gamePhase === 'play' && gameState.currentPlayer === myPosition) {
                const hand = gameState.hands[myPosition];
                if (!hand) return;
                
                let playableCard = null;
                
                if (gameState.currentTrick && gameState.currentTrick.length > 0) {
                    const leadSuit = gameState.currentTrick[0].suit;
                    if (hand[leadSuit] && hand[leadSuit].length > 0) {
                        playableCard = {
                            suit: leadSuit,
                            card: hand[leadSuit][0]
                        };
                    }
                }
                
                if (!playableCard) {
                    for (const suit of ['spades', 'hearts', 'diamonds', 'clubs']) {
                        if (hand[suit] && hand[suit].length > 0) {
                            playableCard = {
                                suit: suit,
                                card: hand[suit][0]
                            };
                            break;
                        }
                    }
                }
                
                if (playableCard) {
                    playCard(playableCard.suit, playableCard.card);
                }
            }
        }
        
        // Direct function for navigation
        function navigate(page) {
            window.location.href = page;
        }

        /**
         * Set up keyboard event listeners
         */
        function setupKeyboardListeners() {
            document.addEventListener('keydown', (e) => {
                // Process keyboard shortcuts
                for (const shortcut of keyboardShortcuts) {
                    if (shortcut.action && // Skip shortcuts with no action (they're handled separately)
                        e.key.toLowerCase() === shortcut.key.toLowerCase() && 
                        (!shortcut.alt || e.altKey) && 
                        (!shortcut.shift || e.shiftKey) && 
                        (!shortcut.ctrl || e.ctrlKey)) {
                        
                        e.preventDefault();
                        shortcut.action();
                        return;
                    }
                }
                
                // Handle s, h, d, c keys with dual purpose:
                // 1. In bidding phase: suit selection for bidding
                // 2. In play phase: focus on lowest card of that suit
                const suitKey = e.key.toLowerCase();
                if (['s', 'h', 'd', 'c'].includes(suitKey) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    
                    // Check game phase and handle accordingly
                    if (gameState && gameState.gamePhase === 'bidding') {
                        // Bidding phase - use for bid suit selection
                        if (suitKey in bidSuitKeys) {
                            handleBidSuitKey(bidSuitKeys[suitKey]);
                        }
                    } else if (gameState && gameState.gamePhase === 'play') {
                        // Play phase - focus on lowest card
                        handleSuitKeyInPlayPhase(suitKey);
                    }
                    return;
                }
                
                // Handle bidding level selection (1-7)
                if (bidLevelKeys.includes(e.key) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    handleBidLevelKey(e.key);
                    return;
                }
                
                // Handle 'n' key for No Trump in bidding
                if (e.key.toLowerCase() === 'n' && !e.altKey && !e.ctrlKey && !e.shiftKey) {
                    e.preventDefault();
                    if (gameState && gameState.gamePhase === 'bidding') {
                        handleBidSuitKey('N');
                    }
                    return;
                }
            });
        }
        
        // Initialize page when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Set solo mode flag
            window.isSoloMode = true;
            
            // Set up keyboard listeners
            setupKeyboardListeners();
            
            // Connect to server
            connectToServer();
            
            // Initialize solo game
            initializeSoloGame();
            
            // Socket events - NOW INCLUDING ALL BIDDING EVENTS
            socket.on('soloGameCreated', (data) => {
                tableCode = data.tableCode;
            });
            
            socket.on('gameStarted', (data) => {
                gameState = data.gameState || {};
                biddingState = data.biddingState || {};
                
                // Initialize game state
                gameState.gamePhase = 'bidding';
                
                // Update UI
                updateGameUI();
                renderBiddingUI();
                
                announceToScreenReader('Game started. Bidding phase begins.');
            });
            
            socket.on('yourCards', (data) => {
                myPosition = data.position;
                if (!gameState) gameState = {};
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                renderHand(data.position, data.cards);
            });
            
            socket.on('bidMade', (data) => {
                biddingState = data.biddingState;
                renderBiddingUI();
                
                const bidText = data.bid === 'P' ? 'passes' : 
                              data.bid === 'X' ? 'doubles' : 
                              data.bid === 'XX' ? 'redoubles' : `bids ${formatBidForDisplay(data.bid)}`;
                announceToScreenReader(`${positionName(data.position)} ${bidText}.`);
            });
            
            socket.on('biddingComplete', (data) => {
                gameState.contract = data.contract;
                gameState.declarer = data.declarer;
                gameState.dummy = data.dummy;
                gameState.trumpSuit = data.trumpSuit;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gamePhase = 'play';
                
                if (biddingState) {
                    biddingState.biddingComplete = true;
                }
                
                document.getElementById('bidding-area').style.display = 'none';
                updateGameUI();
                
                const contractMessage = `Final contract: ${formatContract(data.contract)} by ${positionName(data.declarer)}. ${positionName(data.currentPlayer)} leads.`;
                announceToScreenReader(contractMessage);
            });
            
            socket.on('playPhaseCards', (data) => {
                if (!gameState.hands) gameState.hands = {};
                
                gameState.hands[data.position] = data.cards;
                
                if (data.dummyCards) {
                    gameState.hands[gameState.dummy] = data.dummyCards;
                    renderHand(gameState.dummy, data.dummyCards);
                    announceToScreenReader(`Dummy's cards are now visible.`);
                }
                
                renderHand(data.position, data.cards);
            });
            
            socket.on('cardPlayed', (data) => {
                if (!gameState.currentTrick) gameState.currentTrick = [];
                
                gameState.currentTrick = data.currentTrick;
                
                if (gameState.hands[data.position]) {
                    const suitCards = gameState.hands[data.position][data.suit];
                    if (suitCards) {
                        const index = suitCards.indexOf(data.card);
                        if (index > -1) {
                            suitCards.splice(index, 1);
                        }
                    }
                }
                
                renderHand(data.position, gameState.hands[data.position]);
                updatePlayedCard(data.position, data.suit, data.card);
                
                announceToScreenReader(`${positionName(data.position)} played ${suitName(data.suit)} ${data.card}`);
            });
            
            // MUOKATTU: trickComplete yhdistää tikin voittajan ja seuraavan pelaajan ilmoituksen
            socket.on('trickComplete', (data) => {
                gameState.currentTrick = [];
                gameState.tricks = data.tricks;
                gameState.currentPlayer = data.nextPlayer;
                
                updateCenterArea();
                updateGameUI();
                
                // Yhdistetty ilmoitus: kuka voitti tikin ja kenen vuoro on seuraavaksi
                const winner = positionName(data.winner);
                const next = positionName(data.nextPlayer);
                const isUserNext = data.nextPlayer === myPosition;
                const isDummy = data.nextPlayer === gameState.dummy;
                const weControlDummy = myPosition === gameState.declarer && isDummy;
                
                let message;
                if (isUserNext || weControlDummy) {
                    message = `${winner} won the trick. Your turn to play a card.`;
                } else {
                    message = `${winner} won the trick. ${next} plays next.`;
                }
                
                announceToScreenReader(message);
            });
            
            // MUOKATTU: nextPlayer käsittelijä ei anna enää erillistä ilmoitusta
socket.on('nextPlayer', (data) => {
    gameState.currentPlayer = data.currentPlayer;
    updateGameUI();
    
    // Re-render hands when current player changes (säilytetään ennallaan)
    if (gameState.hands) {
        // Re-render south's hand if south is current player or dummy controller
        if (gameState.hands.south) {
            renderHand('south', gameState.hands.south);
        }
        // Re-render north's hand if north is current player and visible
        if (gameState.hands.north && gameState.gamePhase === 'play') {
            const isNSTeamWon = gameState.declarer === 'south' || gameState.declarer === 'north';
            if (isNSTeamWon) {
                renderHand('north', gameState.hands.north);
            }
        }
    }
    
    // Automaattinen fokuksen siirtyminen pelaajan vuorolla
    const isNSTeamWon = gameState.declarer === 'south' || gameState.declarer === 'north';
    const isMyTurn = data.currentPlayer === 'south' || 
                    (data.currentPlayer === 'north' && isNSTeamWon);
    
    if (isMyTurn && gameState.gamePhase === 'play') {
        setTimeout(() => {
            autoFocusOnRequiredSuit(data.currentPlayer);
        }, 500); // Lyhyt viive että renderöinti ehtii valmistua
    }
    
    // POISTETTU: Ei enää erillistä ilmoitusta vuoronvaihdosta
    // (tämä tieto annetaan nyt trickComplete-viestin yhteydessä)
});

            socket.on('gameOver', (data) => {
                gameState.gamePhase = 'end';
                gameState.tricks = data.tricks;
                
                showGameOver(data.message);
                announceToScreenReader(data.message);
            });
        });
    </script>
</body>
</html>